--- before/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java
+++ after/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java
@@ -31,26 +31,32 @@
 public class ChunkRenderDispatcher
 {
     private static final Logger LOGGER = LogManager.getLogger();
-    private static final ThreadFactory THREAD_FACTORY = new ThreadFactoryBuilder().setNameFormat("Chunk Batcher %d").setDaemon(true).build();
+    private static final ThreadFactory THREAD_FACTORY = (new ThreadFactoryBuilder()).setNameFormat("Chunk Batcher %d").setDaemon(true).build();
     private final int countRenderBuilders;
-    private final List<Thread> listWorkerThreads = Lists.newArrayList();
-    private final List<ChunkRenderWorker> listThreadedWorkers = Lists.newArrayList();
-    private final PriorityBlockingQueue<ChunkCompileTaskGenerator> queueChunkUpdates = Queues.newPriorityBlockingQueue();
+    private final List<Thread> listWorkerThreads = Lists.<Thread>newArrayList();
+    private final List<ChunkRenderWorker> listThreadedWorkers = Lists.<ChunkRenderWorker>newArrayList();
+    private final PriorityBlockingQueue<ChunkCompileTaskGenerator> queueChunkUpdates = Queues.<ChunkCompileTaskGenerator>newPriorityBlockingQueue();
     private final BlockingQueue<RegionRenderCacheBuilder> queueFreeRenderBuilders;
     private final WorldVertexBufferUploader worldVertexUploader = new WorldVertexBufferUploader();
     private final VertexBufferUploader vertexUploader = new VertexBufferUploader();
-    private final Queue<ChunkRenderDispatcher.PendingUpload> queueChunkUploads = Queues.newPriorityQueue();
+    private final Queue<ChunkRenderDispatcher.PendingUpload> queueChunkUploads = Queues.<ChunkRenderDispatcher.PendingUpload>newPriorityQueue();
     private final ChunkRenderWorker renderWorker;
 
     public ChunkRenderDispatcher()
     {
-        int i = Math.max(1, (int)((double)Runtime.getRuntime().maxMemory() * 0.3) / 10485760);
+        this(-1);
+    }
+
+    public ChunkRenderDispatcher(int countRenderBuilders)
+    {
+        int i = Math.max(1, (int)((double)Runtime.getRuntime().maxMemory() * 0.3D) / 10485760);
         int j = Math.max(1, MathHelper.clamp(Runtime.getRuntime().availableProcessors(), 1, i / 5));
-        this.countRenderBuilders = MathHelper.clamp(j * 10, 1, i);
+        if(countRenderBuilders < 0) countRenderBuilders = MathHelper.clamp(j * 10, 1, i);
+        this.countRenderBuilders = countRenderBuilders;
 
         if (j > 1)
         {
-            for (int k = 0; k < j; k++)
+            for (int k = 0; k < j; ++k)
             {
                 ChunkRenderWorker chunkrenderworker = new ChunkRenderWorker(this);
                 Thread thread = THREAD_FACTORY.newThread(chunkrenderworker);
@@ -60,9 +66,9 @@
             }
         }
 
-        this.queueFreeRenderBuilders = Queues.newArrayBlockingQueue(this.countRenderBuilders);
+        this.queueFreeRenderBuilders = Queues.<RegionRenderCacheBuilder>newArrayBlockingQueue(this.countRenderBuilders);
 
-        for (int l = 0; l < this.countRenderBuilders; l++)
+        for (int l = 0; l < this.countRenderBuilders; ++l)
         {
             this.queueFreeRenderBuilders.add(new RegionRenderCacheBuilder());
         }
@@ -72,19 +78,16 @@
 
     public String getDebugInfo()
     {
-        return this.listWorkerThreads.isEmpty()
-               ? String.format("pC: %03d, single-threaded", this.queueChunkUpdates.size())
-               : String.format("pC: %03d, pU: %1d, aB: %1d", this.queueChunkUpdates.size(), this.queueChunkUploads.size(), this.queueFreeRenderBuilders.size());
+        return this.listWorkerThreads.isEmpty() ? String.format("pC: %03d, single-threaded", this.queueChunkUpdates.size()) : String.format("pC: %03d, pU: %1d, aB: %1d", this.queueChunkUpdates.size(), this.queueChunkUploads.size(), this.queueFreeRenderBuilders.size());
     }
 
     public boolean runChunkUploads(long finishTimeNano)
     {
         boolean flag = false;
-        boolean flag1;
 
-        do
+        while (true)
         {
-            flag1 = false;
+            boolean flag1 = false;
 
             if (this.listWorkerThreads.isEmpty())
             {
@@ -97,7 +100,7 @@
                         this.renderWorker.processTask(chunkcompiletaskgenerator);
                         flag1 = true;
                     }
-                    catch (InterruptedException interruptedexception)
+                    catch (InterruptedException var8)
                     {
                         LOGGER.warn("Skipped task due to interrupt");
                     }
@@ -108,13 +111,17 @@
             {
                 if (!this.queueChunkUploads.isEmpty())
                 {
-                    this.queueChunkUploads.poll().uploadTask.run();
+                    (this.queueChunkUploads.poll()).uploadTask.run();
                     flag1 = true;
                     flag = true;
                 }
             }
+
+            if (finishTimeNano == 0L || !flag1 || finishTimeNano < System.nanoTime())
+            {
+                break;
+            }
         }
-        while (finishTimeNano != 0L && flag1 && finishTimeNano >= System.nanoTime());
 
         return flag;
     }
@@ -129,7 +136,6 @@
             final ChunkCompileTaskGenerator chunkcompiletaskgenerator = chunkRenderer.makeCompileTaskChunk();
             chunkcompiletaskgenerator.addFinishRunnable(new Runnable()
             {
-                @Override
                 public void run()
                 {
                     ChunkRenderDispatcher.this.queueChunkUpdates.remove(chunkcompiletaskgenerator);
@@ -165,8 +171,9 @@
             {
                 this.renderWorker.processTask(chunkcompiletaskgenerator);
             }
-            catch (InterruptedException interruptedexception)
+            catch (InterruptedException var7)
             {
+                ;
             }
 
             flag = true;
@@ -182,7 +189,7 @@
     public void stopChunkUpdates()
     {
         this.clearChunkUpdates();
-        List<RegionRenderCacheBuilder> list = Lists.newArrayList();
+        List<RegionRenderCacheBuilder> list = Lists.<RegionRenderCacheBuilder>newArrayList();
 
         while (list.size() != this.countRenderBuilders)
         {
@@ -192,8 +199,9 @@
             {
                 list.add(this.allocateRenderBuilder());
             }
-            catch (InterruptedException interruptedexception)
+            catch (InterruptedException var3)
             {
+                ;
             }
         }
 
@@ -226,12 +234,12 @@
 
             if (chunkcompiletaskgenerator == null)
             {
-                return true;
+                flag = true;
+                return flag;
             }
 
             chunkcompiletaskgenerator.addFinishRunnable(new Runnable()
             {
-                @Override
                 public void run()
                 {
                     ChunkRenderDispatcher.this.queueChunkUpdates.remove(chunkcompiletaskgenerator);
@@ -247,13 +255,7 @@
         return flag;
     }
 
-    public ListenableFuture<Object> uploadChunk(
-        final BlockRenderLayer p_188245_1_,
-        final BufferBuilder p_188245_2_,
-        final RenderChunk p_188245_3_,
-        final CompiledChunk p_188245_4_,
-        final double p_188245_5_
-    )
+    public ListenableFuture<Object> uploadChunk(final BlockRenderLayer p_188245_1_, final BufferBuilder p_188245_2_, final RenderChunk p_188245_3_, final CompiledChunk p_188245_4_, final double p_188245_5_)
     {
         if (Minecraft.getMinecraft().isCallingFromMinecraftThread())
         {
@@ -266,19 +268,18 @@
                 this.uploadDisplayList(p_188245_2_, ((ListedRenderChunk)p_188245_3_).getDisplayList(p_188245_1_, p_188245_4_), p_188245_3_);
             }
 
-            p_188245_2_.setTranslation(0.0, 0.0, 0.0);
-            return Futures.immediateFuture(null);
+            p_188245_2_.setTranslation(0.0D, 0.0D, 0.0D);
+            return Futures.<Object>immediateFuture((Object)null);
         }
         else
         {
-            ListenableFutureTask<Object> listenablefuturetask = ListenableFutureTask.create(new Runnable()
+            ListenableFutureTask<Object> listenablefuturetask = ListenableFutureTask.<Object>create(new Runnable()
             {
-                @Override
                 public void run()
                 {
                     ChunkRenderDispatcher.this.uploadChunk(p_188245_1_, p_188245_2_, p_188245_3_, p_188245_4_, p_188245_5_);
                 }
-            }, null);
+            }, (Object)null);
 
             synchronized (this.queueChunkUploads)
             {
