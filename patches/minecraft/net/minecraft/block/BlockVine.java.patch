--- before/net/minecraft/block/BlockVine.java
+++ after/net/minecraft/block/BlockVine.java
@@ -3,6 +3,7 @@
 import java.util.Random;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.Material;
+import net.minecraft.block.properties.IProperty;
 import net.minecraft.block.properties.PropertyBool;
 import net.minecraft.block.state.BlockFaceShape;
 import net.minecraft.block.state.BlockStateContainer;
@@ -27,7 +28,7 @@
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 
-public class BlockVine extends Block
+public class BlockVine extends Block implements net.minecraftforge.common.IShearable
 {
     public static final PropertyBool UP = PropertyBool.create("up");
     public static final PropertyBool NORTH = PropertyBool.create("north");
@@ -35,103 +36,86 @@
     public static final PropertyBool SOUTH = PropertyBool.create("south");
     public static final PropertyBool WEST = PropertyBool.create("west");
     public static final PropertyBool[] ALL_FACES = new PropertyBool[] {UP, NORTH, SOUTH, WEST, EAST};
-    protected static final AxisAlignedBB UP_AABB = new AxisAlignedBB(0.0, 0.9375, 0.0, 1.0, 1.0, 1.0);
-    protected static final AxisAlignedBB WEST_AABB = new AxisAlignedBB(0.0, 0.0, 0.0, 0.0625, 1.0, 1.0);
-    protected static final AxisAlignedBB EAST_AABB = new AxisAlignedBB(0.9375, 0.0, 0.0, 1.0, 1.0, 1.0);
-    protected static final AxisAlignedBB NORTH_AABB = new AxisAlignedBB(0.0, 0.0, 0.0, 1.0, 1.0, 0.0625);
-    protected static final AxisAlignedBB SOUTH_AABB = new AxisAlignedBB(0.0, 0.0, 0.9375, 1.0, 1.0, 1.0);
+    protected static final AxisAlignedBB UP_AABB = new AxisAlignedBB(0.0D, 0.9375D, 0.0D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB WEST_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0625D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB EAST_AABB = new AxisAlignedBB(0.9375D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB NORTH_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 0.0625D);
+    protected static final AxisAlignedBB SOUTH_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.9375D, 1.0D, 1.0D, 1.0D);
 
     public BlockVine()
     {
         super(Material.VINE);
-        this.setDefaultState(
-            this.blockState
-            .getBaseState()
-            .withProperty(UP, false)
-            .withProperty(NORTH, false)
-            .withProperty(EAST, false)
-            .withProperty(SOUTH, false)
-            .withProperty(WEST, false)
-        );
+        this.setDefaultState(this.blockState.getBaseState().withProperty(UP, Boolean.valueOf(false)).withProperty(NORTH, Boolean.valueOf(false)).withProperty(EAST, Boolean.valueOf(false)).withProperty(SOUTH, Boolean.valueOf(false)).withProperty(WEST, Boolean.valueOf(false)));
         this.setTickRandomly(true);
         this.setCreativeTab(CreativeTabs.DECORATIONS);
     }
 
     @Nullable
-    @Override
     public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos)
     {
         return NULL_AABB;
     }
 
-    @Override
     public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos)
     {
         state = state.getActualState(source, pos);
         int i = 0;
         AxisAlignedBB axisalignedbb = FULL_BLOCK_AABB;
 
-        if (state.getValue(UP))
+        if (((Boolean)state.getValue(UP)).booleanValue())
         {
             axisalignedbb = UP_AABB;
-            i++;
+            ++i;
         }
 
-        if (state.getValue(NORTH))
+        if (((Boolean)state.getValue(NORTH)).booleanValue())
         {
             axisalignedbb = NORTH_AABB;
-            i++;
+            ++i;
         }
 
-        if (state.getValue(EAST))
+        if (((Boolean)state.getValue(EAST)).booleanValue())
         {
             axisalignedbb = EAST_AABB;
-            i++;
+            ++i;
         }
 
-        if (state.getValue(SOUTH))
+        if (((Boolean)state.getValue(SOUTH)).booleanValue())
         {
             axisalignedbb = SOUTH_AABB;
-            i++;
+            ++i;
         }
 
-        if (state.getValue(WEST))
+        if (((Boolean)state.getValue(WEST)).booleanValue())
         {
             axisalignedbb = WEST_AABB;
-            i++;
+            ++i;
         }
 
         return i == 1 ? axisalignedbb : FULL_BLOCK_AABB;
     }
 
-    @Override
     public IBlockState getActualState(IBlockState state, IBlockAccess worldIn, BlockPos pos)
     {
         BlockPos blockpos = pos.up();
-        return state.withProperty(
-                   UP, worldIn.getBlockState(blockpos).getBlockFaceShape(worldIn, blockpos, EnumFacing.DOWN) == BlockFaceShape.SOLID
-               );
+        return state.withProperty(UP, Boolean.valueOf(worldIn.getBlockState(blockpos).getBlockFaceShape(worldIn, blockpos, EnumFacing.DOWN) == BlockFaceShape.SOLID));
     }
 
-    @Override
     public boolean isOpaqueCube(IBlockState state)
     {
         return false;
     }
 
-    @Override
     public boolean isFullCube(IBlockState state)
     {
         return false;
     }
 
-    @Override
     public boolean isReplaceable(IBlockAccess worldIn, BlockPos pos)
     {
         return true;
     }
 
-    @Override
     public boolean canPlaceBlockOnSide(World worldIn, BlockPos pos, EnumFacing side)
     {
         return side != EnumFacing.DOWN && side != EnumFacing.UP && this.canAttachTo(worldIn, pos, side);
@@ -140,8 +124,7 @@
     public boolean canAttachTo(World p_193395_1_, BlockPos p_193395_2_, EnumFacing p_193395_3_)
     {
         Block block = p_193395_1_.getBlockState(p_193395_2_.up()).getBlock();
-        return this.isAcceptableNeighbor(p_193395_1_, p_193395_2_.offset(p_193395_3_.getOpposite()), p_193395_3_)
-               && (block == Blocks.AIR || block == Blocks.VINE || this.isAcceptableNeighbor(p_193395_1_, p_193395_2_.up(), EnumFacing.UP));
+        return this.isAcceptableNeighbor(p_193395_1_, p_193395_2_.offset(p_193395_3_.getOpposite()), p_193395_3_) && (block == Blocks.AIR || block == Blocks.VINE || this.isAcceptableNeighbor(p_193395_1_, p_193395_2_.up(), EnumFacing.UP));
     }
 
     private boolean isAcceptableNeighbor(World p_193396_1_, BlockPos p_193396_2_, EnumFacing p_193396_3_)
@@ -152,15 +135,7 @@
 
     protected static boolean isExceptBlockForAttaching(Block p_193397_0_)
     {
-        return p_193397_0_ instanceof BlockShulkerBox
-               || p_193397_0_ == Blocks.BEACON
-               || p_193397_0_ == Blocks.CAULDRON
-               || p_193397_0_ == Blocks.GLASS
-               || p_193397_0_ == Blocks.STAINED_GLASS
-               || p_193397_0_ == Blocks.PISTON
-               || p_193397_0_ == Blocks.STICKY_PISTON
-               || p_193397_0_ == Blocks.PISTON_HEAD
-               || p_193397_0_ == Blocks.TRAPDOOR;
+        return p_193397_0_ instanceof BlockShulkerBox || p_193397_0_ == Blocks.BEACON || p_193397_0_ == Blocks.CAULDRON || p_193397_0_ == Blocks.GLASS || p_193397_0_ == Blocks.STAINED_GLASS || p_193397_0_ == Blocks.PISTON || p_193397_0_ == Blocks.STICKY_PISTON || p_193397_0_ == Blocks.PISTON_HEAD || p_193397_0_ == Blocks.TRAPDOOR;
     }
 
     private boolean recheckGrownSides(World worldIn, BlockPos pos, IBlockState state)
@@ -171,13 +146,13 @@
         {
             PropertyBool propertybool = getPropertyFor(enumfacing);
 
-            if (state.getValue(propertybool) && !this.canAttachTo(worldIn, pos, enumfacing.getOpposite()))
+            if (((Boolean)state.getValue(propertybool)).booleanValue() && !this.canAttachTo(worldIn, pos, enumfacing.getOpposite()))
             {
                 IBlockState iblockstate1 = worldIn.getBlockState(pos.up());
 
-                if (iblockstate1.getBlock() != this || !iblockstate1.getValue(propertybool))
+                if (iblockstate1.getBlock() != this || !((Boolean)iblockstate1.getValue(propertybool)).booleanValue())
                 {
-                    state = state.withProperty(propertybool, false);
+                    state = state.withProperty(propertybool, Boolean.valueOf(false));
                 }
             }
         }
@@ -197,7 +172,6 @@
         }
     }
 
-    @Override
     public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos)
     {
         if (!worldIn.isRemote && !this.recheckGrownSides(worldIn, pos, state))
@@ -207,193 +181,168 @@
         }
     }
 
-    @Override
     public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand)
     {
         if (!worldIn.isRemote)
         {
-            if (worldIn.rand.nextInt(4) == 0)
+            if (worldIn.rand.nextInt(4) == 0 && worldIn.isAreaLoaded(pos, 4)) // Forge: check area to prevent loading unloaded chunks
             {
                 int i = 4;
                 int j = 5;
                 boolean flag = false;
-                label179:
+                label181:
 
-                for (int k = -4; k <= 4; k++)
+                for (int k = -4; k <= 4; ++k)
                 {
-                    for (int l = -4; l <= 4; l++)
+                    for (int l = -4; l <= 4; ++l)
                     {
-                        for (int i1 = -1; i1 <= 1; i1++)
+                        for (int i1 = -1; i1 <= 1; ++i1)
                         {
                             if (worldIn.getBlockState(pos.add(k, i1, l)).getBlock() == this)
                             {
-                                if (--j <= 0)
+                                --j;
+
+                                if (j <= 0)
                                 {
                                     flag = true;
-                                    break label179;
+                                    break label181;
                                 }
                             }
                         }
                     }
                 }
 
-                EnumFacing enumfacing2 = EnumFacing.random(rand);
+                EnumFacing enumfacing1 = EnumFacing.random(rand);
                 BlockPos blockpos2 = pos.up();
 
-                if (enumfacing2 == EnumFacing.UP && pos.getY() < 255 && worldIn.isAirBlock(blockpos2))
+                if (enumfacing1 == EnumFacing.UP && pos.getY() < 255 && worldIn.isAirBlock(blockpos2))
                 {
-                    IBlockState iblockstate1 = state;
+                    IBlockState iblockstate2 = state;
 
-                    for (EnumFacing enumfacing3 : EnumFacing.Plane.HORIZONTAL)
+                    for (EnumFacing enumfacing2 : EnumFacing.Plane.HORIZONTAL)
                     {
-                        if (rand.nextBoolean() && this.canAttachTo(worldIn, blockpos2, enumfacing3.getOpposite()))
+                        if (rand.nextBoolean() && this.canAttachTo(worldIn, blockpos2, enumfacing2.getOpposite()))
                         {
-                            iblockstate1 = iblockstate1.withProperty(getPropertyFor(enumfacing3), true);
+                            iblockstate2 = iblockstate2.withProperty(getPropertyFor(enumfacing2), Boolean.valueOf(true));
                         }
                         else
                         {
-                            iblockstate1 = iblockstate1.withProperty(getPropertyFor(enumfacing3), false);
-                        }
-                    }
-
-                    if (iblockstate1.getValue(NORTH)
-                            || iblockstate1.getValue(EAST)
-                            || iblockstate1.getValue(SOUTH)
-                            || iblockstate1.getValue(WEST))
-                    {
-                        worldIn.setBlockState(blockpos2, iblockstate1, 2);
-                    }
-                }
-                else if (!enumfacing2.getAxis().isHorizontal() || state.getValue(getPropertyFor(enumfacing2)))
+                            iblockstate2 = iblockstate2.withProperty(getPropertyFor(enumfacing2), Boolean.valueOf(false));
+                        }
+                    }
+
+                    if (((Boolean)iblockstate2.getValue(NORTH)).booleanValue() || ((Boolean)iblockstate2.getValue(EAST)).booleanValue() || ((Boolean)iblockstate2.getValue(SOUTH)).booleanValue() || ((Boolean)iblockstate2.getValue(WEST)).booleanValue())
+                    {
+                        worldIn.setBlockState(blockpos2, iblockstate2, 2);
+                    }
+                }
+                else if (enumfacing1.getAxis().isHorizontal() && !((Boolean)state.getValue(getPropertyFor(enumfacing1))).booleanValue())
+                {
+                    if (!flag)
+                    {
+                        BlockPos blockpos4 = pos.offset(enumfacing1);
+                        IBlockState iblockstate3 = worldIn.getBlockState(blockpos4);
+                        Block block1 = iblockstate3.getBlock();
+
+                        if (block1.isAir(iblockstate3, worldIn, blockpos4))
+                        {
+                            EnumFacing enumfacing3 = enumfacing1.rotateY();
+                            EnumFacing enumfacing4 = enumfacing1.rotateYCCW();
+                            boolean flag1 = ((Boolean)state.getValue(getPropertyFor(enumfacing3))).booleanValue();
+                            boolean flag2 = ((Boolean)state.getValue(getPropertyFor(enumfacing4))).booleanValue();
+                            BlockPos blockpos = blockpos4.offset(enumfacing3);
+                            BlockPos blockpos1 = blockpos4.offset(enumfacing4);
+
+                            if (flag1 && this.canAttachTo(worldIn, blockpos.offset(enumfacing3), enumfacing3))
+                            {
+                                worldIn.setBlockState(blockpos4, this.getDefaultState().withProperty(getPropertyFor(enumfacing3), Boolean.valueOf(true)), 2);
+                            }
+                            else if (flag2 && this.canAttachTo(worldIn, blockpos1.offset(enumfacing4), enumfacing4))
+                            {
+                                worldIn.setBlockState(blockpos4, this.getDefaultState().withProperty(getPropertyFor(enumfacing4), Boolean.valueOf(true)), 2);
+                            }
+                            else if (flag1 && worldIn.isAirBlock(blockpos) && this.canAttachTo(worldIn, blockpos, enumfacing1))
+                            {
+                                worldIn.setBlockState(blockpos, this.getDefaultState().withProperty(getPropertyFor(enumfacing1.getOpposite()), Boolean.valueOf(true)), 2);
+                            }
+                            else if (flag2 && worldIn.isAirBlock(blockpos1) && this.canAttachTo(worldIn, blockpos1, enumfacing1))
+                            {
+                                worldIn.setBlockState(blockpos1, this.getDefaultState().withProperty(getPropertyFor(enumfacing1.getOpposite()), Boolean.valueOf(true)), 2);
+                            }
+                        }
+                        else if (iblockstate3.getBlockFaceShape(worldIn, blockpos4, enumfacing1) == BlockFaceShape.SOLID)
+                        {
+                            worldIn.setBlockState(pos, state.withProperty(getPropertyFor(enumfacing1), Boolean.valueOf(true)), 2);
+                        }
+                    }
+                }
+                else
                 {
                     if (pos.getY() > 1)
                     {
-                        BlockPos blockpos4 = pos.down();
-                        IBlockState iblockstate2 = worldIn.getBlockState(blockpos4);
-                        Block block1 = iblockstate2.getBlock();
+                        BlockPos blockpos3 = pos.down();
+                        IBlockState iblockstate = worldIn.getBlockState(blockpos3);
+                        Block block = iblockstate.getBlock();
 
-                        if (block1.material == Material.AIR)
+                        if (block.material == Material.AIR)
                         {
-                            IBlockState iblockstate3 = state;
+                            IBlockState iblockstate1 = state;
 
-                            for (EnumFacing enumfacing4 : EnumFacing.Plane.HORIZONTAL)
+                            for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
                             {
                                 if (rand.nextBoolean())
                                 {
-                                    iblockstate3 = iblockstate3.withProperty(getPropertyFor(enumfacing4), false);
+                                    iblockstate1 = iblockstate1.withProperty(getPropertyFor(enumfacing), Boolean.valueOf(false));
                                 }
                             }
 
-                            if (iblockstate3.getValue(NORTH)
-                                    || iblockstate3.getValue(EAST)
-                                    || iblockstate3.getValue(SOUTH)
-                                    || iblockstate3.getValue(WEST))
+                            if (((Boolean)iblockstate1.getValue(NORTH)).booleanValue() || ((Boolean)iblockstate1.getValue(EAST)).booleanValue() || ((Boolean)iblockstate1.getValue(SOUTH)).booleanValue() || ((Boolean)iblockstate1.getValue(WEST)).booleanValue())
                             {
-                                worldIn.setBlockState(blockpos4, iblockstate3, 2);
+                                worldIn.setBlockState(blockpos3, iblockstate1, 2);
                             }
                         }
-                        else if (block1 == this)
+                        else if (block == this)
                         {
-                            IBlockState iblockstate4 = iblockstate2;
+                            IBlockState iblockstate4 = iblockstate;
 
                             for (EnumFacing enumfacing5 : EnumFacing.Plane.HORIZONTAL)
                             {
                                 PropertyBool propertybool = getPropertyFor(enumfacing5);
 
-                                if (rand.nextBoolean() && state.getValue(propertybool))
+                                if (rand.nextBoolean() && ((Boolean)state.getValue(propertybool)).booleanValue())
                                 {
-                                    iblockstate4 = iblockstate4.withProperty(propertybool, true);
+                                    iblockstate4 = iblockstate4.withProperty(propertybool, Boolean.valueOf(true));
                                 }
                             }
 
-                            if (iblockstate4.getValue(NORTH)
-                                    || iblockstate4.getValue(EAST)
-                                    || iblockstate4.getValue(SOUTH)
-                                    || iblockstate4.getValue(WEST))
+                            if (((Boolean)iblockstate4.getValue(NORTH)).booleanValue() || ((Boolean)iblockstate4.getValue(EAST)).booleanValue() || ((Boolean)iblockstate4.getValue(SOUTH)).booleanValue() || ((Boolean)iblockstate4.getValue(WEST)).booleanValue())
                             {
-                                worldIn.setBlockState(blockpos4, iblockstate4, 2);
+                                worldIn.setBlockState(blockpos3, iblockstate4, 2);
                             }
                         }
-                    }
-                }
-                else if (!flag)
-                {
-                    BlockPos blockpos3 = pos.offset(enumfacing2);
-                    IBlockState iblockstate = worldIn.getBlockState(blockpos3);
-                    Block block = iblockstate.getBlock();
-
-                    if (block.material == Material.AIR)
-                    {
-                        EnumFacing enumfacing = enumfacing2.rotateY();
-                        EnumFacing enumfacing1 = enumfacing2.rotateYCCW();
-                        boolean flag1 = state.getValue(getPropertyFor(enumfacing));
-                        boolean flag2 = state.getValue(getPropertyFor(enumfacing1));
-                        BlockPos blockpos = blockpos3.offset(enumfacing);
-                        BlockPos blockpos1 = blockpos3.offset(enumfacing1);
-
-                        if (flag1 && this.canAttachTo(worldIn, blockpos.offset(enumfacing), enumfacing))
-                        {
-                            worldIn.setBlockState(blockpos3, this.getDefaultState().withProperty(getPropertyFor(enumfacing), true), 2);
-                        }
-                        else if (flag2 && this.canAttachTo(worldIn, blockpos1.offset(enumfacing1), enumfacing1))
-                        {
-                            worldIn.setBlockState(blockpos3, this.getDefaultState().withProperty(getPropertyFor(enumfacing1), true), 2);
-                        }
-                        else if (flag1 && worldIn.isAirBlock(blockpos) && this.canAttachTo(worldIn, blockpos, enumfacing2))
-                        {
-                            worldIn.setBlockState(blockpos, this.getDefaultState().withProperty(getPropertyFor(enumfacing2.getOpposite()), true), 2);
-                        }
-                        else if (flag2 && worldIn.isAirBlock(blockpos1) && this.canAttachTo(worldIn, blockpos1, enumfacing2))
-                        {
-                            worldIn.setBlockState(blockpos1, this.getDefaultState().withProperty(getPropertyFor(enumfacing2.getOpposite()), true), 2);
-                        }
-                    }
-                    else if (iblockstate.getBlockFaceShape(worldIn, blockpos3, enumfacing2) == BlockFaceShape.SOLID)
-                    {
-                        worldIn.setBlockState(pos, state.withProperty(getPropertyFor(enumfacing2), true), 2);
                     }
                 }
             }
         }
     }
 
-    @Override
-    public IBlockState getStateForPlacement(
-        World worldIn,
-        BlockPos pos,
-        EnumFacing facing,
-        float hitX,
-        float hitY,
-        float hitZ,
-        int meta,
-        EntityLivingBase placer
-    )
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer)
     {
-        IBlockState iblockstate = this.getDefaultState()
-                                  .withProperty(UP, false)
-                                  .withProperty(NORTH, false)
-                                  .withProperty(EAST, false)
-                                  .withProperty(SOUTH, false)
-                                  .withProperty(WEST, false);
-        return facing.getAxis().isHorizontal() ? iblockstate.withProperty(getPropertyFor(facing.getOpposite()), true) : iblockstate;
+        IBlockState iblockstate = this.getDefaultState().withProperty(UP, Boolean.valueOf(false)).withProperty(NORTH, Boolean.valueOf(false)).withProperty(EAST, Boolean.valueOf(false)).withProperty(SOUTH, Boolean.valueOf(false)).withProperty(WEST, Boolean.valueOf(false));
+        return facing.getAxis().isHorizontal() ? iblockstate.withProperty(getPropertyFor(facing.getOpposite()), Boolean.valueOf(true)) : iblockstate;
     }
 
-    @Override
     public Item getItemDropped(IBlockState state, Random rand, int fortune)
     {
         return Items.AIR;
     }
 
-    @Override
     public int quantityDropped(Random random)
     {
         return 0;
     }
 
-    @Override
-    public void harvestBlock(
-        World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack
-    )
+    public void harvestBlock(World worldIn, EntityPlayer player, BlockPos pos, IBlockState state, @Nullable TileEntity te, ItemStack stack)
     {
         if (!worldIn.isRemote && stack.getItem() == Items.SHEARS)
         {
@@ -406,44 +355,37 @@
         }
     }
 
+    public IBlockState getStateFromMeta(int meta)
+    {
+        return this.getDefaultState().withProperty(SOUTH, Boolean.valueOf((meta & 1) > 0)).withProperty(WEST, Boolean.valueOf((meta & 2) > 0)).withProperty(NORTH, Boolean.valueOf((meta & 4) > 0)).withProperty(EAST, Boolean.valueOf((meta & 8) > 0));
+    }
+
     @SideOnly(Side.CLIENT)
-    @Override
     public BlockRenderLayer getRenderLayer()
     {
         return BlockRenderLayer.CUTOUT;
     }
 
-    @Override
-    public IBlockState getStateFromMeta(int meta)
-    {
-        return this.getDefaultState()
-               .withProperty(SOUTH, (meta & 1) > 0)
-               .withProperty(WEST, (meta & 2) > 0)
-               .withProperty(NORTH, (meta & 4) > 0)
-               .withProperty(EAST, (meta & 8) > 0);
-    }
-
-    @Override
     public int getMetaFromState(IBlockState state)
     {
         int i = 0;
 
-        if (state.getValue(SOUTH))
+        if (((Boolean)state.getValue(SOUTH)).booleanValue())
         {
             i |= 1;
         }
 
-        if (state.getValue(WEST))
+        if (((Boolean)state.getValue(WEST)).booleanValue())
         {
             i |= 2;
         }
 
-        if (state.getValue(NORTH))
+        if (((Boolean)state.getValue(NORTH)).booleanValue())
         {
             i |= 4;
         }
 
-        if (state.getValue(EAST))
+        if (((Boolean)state.getValue(EAST)).booleanValue())
         {
             i |= 8;
         }
@@ -451,48 +393,34 @@
         return i;
     }
 
-    @Override
     protected BlockStateContainer createBlockState()
     {
-        return new BlockStateContainer(this, UP, NORTH, EAST, SOUTH, WEST);
+        return new BlockStateContainer(this, new IProperty[] {UP, NORTH, EAST, SOUTH, WEST});
     }
 
-    @Override
     public IBlockState withRotation(IBlockState state, Rotation rot)
     {
         switch (rot)
         {
             case CLOCKWISE_180:
-                return state.withProperty(NORTH, state.getValue(SOUTH))
-                       .withProperty(EAST, state.getValue(WEST))
-                       .withProperty(SOUTH, state.getValue(NORTH))
-                       .withProperty(WEST, state.getValue(EAST));
+                return state.withProperty(NORTH, state.getValue(SOUTH)).withProperty(EAST, state.getValue(WEST)).withProperty(SOUTH, state.getValue(NORTH)).withProperty(WEST, state.getValue(EAST));
             case COUNTERCLOCKWISE_90:
-                return state.withProperty(NORTH, state.getValue(EAST))
-                       .withProperty(EAST, state.getValue(SOUTH))
-                       .withProperty(SOUTH, state.getValue(WEST))
-                       .withProperty(WEST, state.getValue(NORTH));
+                return state.withProperty(NORTH, state.getValue(EAST)).withProperty(EAST, state.getValue(SOUTH)).withProperty(SOUTH, state.getValue(WEST)).withProperty(WEST, state.getValue(NORTH));
             case CLOCKWISE_90:
-                return state.withProperty(NORTH, state.getValue(WEST))
-                       .withProperty(EAST, state.getValue(NORTH))
-                       .withProperty(SOUTH, state.getValue(EAST))
-                       .withProperty(WEST, state.getValue(SOUTH));
+                return state.withProperty(NORTH, state.getValue(WEST)).withProperty(EAST, state.getValue(NORTH)).withProperty(SOUTH, state.getValue(EAST)).withProperty(WEST, state.getValue(SOUTH));
             default:
                 return state;
         }
     }
 
-    @Override
     public IBlockState withMirror(IBlockState state, Mirror mirrorIn)
     {
         switch (mirrorIn)
         {
             case LEFT_RIGHT:
-                return state.withProperty(NORTH, state.getValue(SOUTH))
-                       .withProperty(SOUTH, state.getValue(NORTH));
+                return state.withProperty(NORTH, state.getValue(SOUTH)).withProperty(SOUTH, state.getValue(NORTH));
             case FRONT_BACK:
-                return state.withProperty(EAST, state.getValue(WEST))
-                       .withProperty(WEST, state.getValue(EAST));
+                return state.withProperty(EAST, state.getValue(WEST)).withProperty(WEST, state.getValue(EAST));
             default:
                 return super.withMirror(state, mirrorIn);
         }
@@ -523,16 +451,25 @@
 
         for (PropertyBool propertybool : ALL_FACES)
         {
-            if (state.getValue(propertybool))
+            if (((Boolean)state.getValue(propertybool)).booleanValue())
             {
-                i++;
+                ++i;
             }
         }
 
         return i;
     }
-
+    /*************************FORGE START***********************************/
+    @Override public boolean isLadder(IBlockState state, IBlockAccess world, BlockPos pos, EntityLivingBase entity){ return true; }
+    @Override public boolean isShearable(ItemStack item, IBlockAccess world, BlockPos pos){ return true; }
     @Override
+    public java.util.List<ItemStack> onSheared(ItemStack item, IBlockAccess world, BlockPos pos, int fortune)
+    {
+        return java.util.Arrays.asList(new ItemStack(this, 1));
+    }
+    /*************************FORGE END***********************************/
+
+
     public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face)
     {
         return BlockFaceShape.UNDEFINED;
