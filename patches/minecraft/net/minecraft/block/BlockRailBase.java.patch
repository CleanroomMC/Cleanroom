--- before/net/minecraft/block/BlockRailBase.java
+++ after/net/minecraft/block/BlockRailBase.java
@@ -22,8 +22,8 @@
 
 public abstract class BlockRailBase extends Block
 {
-    protected static final AxisAlignedBB FLAT_AABB = new AxisAlignedBB(0.0, 0.0, 0.0, 1.0, 0.125, 1.0);
-    protected static final AxisAlignedBB ASCENDING_AABB = new AxisAlignedBB(0.0, 0.0, 0.0, 1.0, 0.5, 1.0);
+    protected static final AxisAlignedBB FLAT_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.125D, 1.0D);
+    protected static final AxisAlignedBB ASCENDING_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.5D, 1.0D);
     protected final boolean isPowered;
 
     public static boolean isRailBlock(World worldIn, BlockPos pos)
@@ -34,7 +34,7 @@
     public static boolean isRailBlock(IBlockState state)
     {
         Block block = state.getBlock();
-        return block == Blocks.RAIL || block == Blocks.GOLDEN_RAIL || block == Blocks.DETECTOR_RAIL || block == Blocks.ACTIVATOR_RAIL;
+        return block instanceof BlockRailBase;
     }
 
     protected BlockRailBase(boolean isPowered)
@@ -45,46 +45,37 @@
     }
 
     @Nullable
-    @Override
     public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos)
     {
         return NULL_AABB;
     }
 
-    @Override
     public boolean isOpaqueCube(IBlockState state)
     {
         return false;
     }
 
-    @Override
     public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos)
     {
-        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = state.getBlock() == this
-                ? state.getValue(this.getShapeProperty())
-                : null;
+        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = state.getBlock() == this ? getRailDirection(source, pos, state, null) : null;
         return blockrailbase$enumraildirection != null && blockrailbase$enumraildirection.isAscending() ? ASCENDING_AABB : FLAT_AABB;
     }
 
-    @Override
     public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face)
     {
         return BlockFaceShape.UNDEFINED;
     }
 
-    @Override
     public boolean isFullCube(IBlockState state)
     {
         return false;
     }
 
-    @Override
     public boolean canPlaceBlockAt(World worldIn, BlockPos pos)
     {
-        return worldIn.getBlockState(pos.down()).isTopSolid();
+        return worldIn.getBlockState(pos.down()).isSideSolid(worldIn, pos.down(), EnumFacing.UP);
     }
 
-    @Override
     public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state)
     {
         if (!worldIn.isRemote)
@@ -98,41 +89,37 @@
         }
     }
 
-    @Override
     public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos)
     {
         if (!worldIn.isRemote)
         {
-            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = state.getValue(this.getShapeProperty());
+            final IBlockState currentState = worldIn.getBlockState(pos);
+            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = getRailDirection(worldIn, pos, currentState.getBlock() == this ? currentState : state, null);
             boolean flag = false;
 
-            if (!worldIn.getBlockState(pos.down()).isTopSolid())
-            {
-                flag = true;
-            }
-
-            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_EAST
-                    && !worldIn.getBlockState(pos.east()).isTopSolid())
-            {
-                flag = true;
-            }
-            else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_WEST
-                     && !worldIn.getBlockState(pos.west()).isTopSolid())
-            {
-                flag = true;
-            }
-            else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_NORTH
-                     && !worldIn.getBlockState(pos.north()).isTopSolid())
-            {
-                flag = true;
-            }
-            else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_SOUTH
-                     && !worldIn.getBlockState(pos.south()).isTopSolid())
-            {
-                flag = true;
-            }
-
-            if (flag && !worldIn.isAirBlock(pos))
+            if (!worldIn.getBlockState(pos.down()).isSideSolid(worldIn, pos.down(), EnumFacing.UP))
+            {
+                flag = true;
+            }
+
+            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_EAST && !worldIn.getBlockState(pos.east()).isSideSolid(worldIn, pos.east(), EnumFacing.UP))
+            {
+                flag = true;
+            }
+            else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_WEST && !worldIn.getBlockState(pos.west()).isSideSolid(worldIn, pos.west(), EnumFacing.UP))
+            {
+                flag = true;
+            }
+            else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_NORTH && !worldIn.getBlockState(pos.north()).isSideSolid(worldIn, pos.north(), EnumFacing.UP))
+            {
+                flag = true;
+            }
+            else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.ASCENDING_SOUTH && !worldIn.getBlockState(pos.south()).isSideSolid(worldIn, pos.south(), EnumFacing.UP))
+            {
+                flag = true;
+            }
+
+            if (flag && !currentState.getBlock().isAir(currentState, worldIn, pos))
             {
                 this.dropBlockAsItem(worldIn, pos, state, 0);
                 worldIn.setBlockToAir(pos);
@@ -150,30 +137,25 @@
 
     protected IBlockState updateDir(World worldIn, BlockPos pos, IBlockState state, boolean initialPlacement)
     {
-        return worldIn.isRemote
-               ? state
-               : new BlockRailBase.Rail(worldIn, pos, state).place(worldIn.isBlockPowered(pos), initialPlacement).getBlockState();
+        return worldIn.isRemote ? state : (new BlockRailBase.Rail(worldIn, pos, state)).place(worldIn.isBlockPowered(pos), initialPlacement).getBlockState();
     }
 
-    @Override
     public EnumPushReaction getPushReaction(IBlockState state)
     {
         return EnumPushReaction.NORMAL;
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public BlockRenderLayer getRenderLayer()
     {
         return BlockRenderLayer.CUTOUT;
     }
 
-    @Override
     public void breakBlock(World worldIn, BlockPos pos, IBlockState state)
     {
         super.breakBlock(worldIn, pos, state);
 
-        if (state.getValue(this.getShapeProperty()).isAscending())
+        if (getRailDirection(worldIn, pos, state, null).isAscending())
         {
             worldIn.notifyNeighborsOfStateChange(pos.up(), this, false);
         }
@@ -185,8 +167,101 @@
         }
     }
 
+    //Forge: Use getRailDirection(IBlockAccess, BlockPos, IBlockState, EntityMinecart) for enhanced ability
     public abstract IProperty<BlockRailBase.EnumRailDirection> getShapeProperty();
 
+    /* ======================================== FORGE START =====================================*/
+    /**
+     * Return true if the rail can make corners.
+     * Used by placement logic.
+     * @param world The world.
+     * @param pos Block's position in world
+     * @return True if the rail can make corners.
+     */
+    public boolean isFlexibleRail(IBlockAccess world, BlockPos pos)
+    {
+        return !this.isPowered;
+    }
+
+    /**
+     * Returns true if the rail can make up and down slopes.
+     * Used by placement logic.
+     * @param world The world.
+     * @param pos Block's position in world
+     * @return True if the rail can make slopes.
+     */
+    public boolean canMakeSlopes(IBlockAccess world, BlockPos pos)
+    {
+        return true;
+    }
+
+    /**
+     * Return the rail's direction.
+     * Can be used to make the cart think the rail is a different shape,
+     * for example when making diamond junctions or switches.
+     * The cart parameter will often be null unless it it called from EntityMinecart.
+     *
+     * @param world The world.
+     * @param pos Block's position in world
+     * @param state The BlockState
+     * @param cart The cart asking for the metadata, null if it is not called by EntityMinecart.
+     * @return The direction.
+     */
+    public EnumRailDirection getRailDirection(IBlockAccess world, BlockPos pos, IBlockState state, @javax.annotation.Nullable net.minecraft.entity.item.EntityMinecart cart)
+    {
+        return state.getValue(getShapeProperty());
+    }
+
+    /**
+     * Returns the max speed of the rail at the specified position.
+     * @param world The world.
+     * @param cart The cart on the rail, may be null.
+     * @param pos Block's position in world
+     * @return The max speed of the current rail.
+     */
+    public float getRailMaxSpeed(World world, net.minecraft.entity.item.EntityMinecart cart, BlockPos pos)
+    {
+        return 0.4f;
+    }
+
+    /**
+     * This function is called by any minecart that passes over this rail.
+     * It is called once per update tick that the minecart is on the rail.
+     * @param world The world.
+     * @param cart The cart on the rail.
+     * @param pos Block's position in world
+     */
+    public void onMinecartPass(World world, net.minecraft.entity.item.EntityMinecart cart, BlockPos pos)
+    {
+    }
+
+    /**
+     * Rotate the block. For vanilla blocks this rotates around the axis passed in (generally, it should be the "face" that was hit).
+     * Note: for mod blocks, this is up to the block and modder to decide. It is not mandated that it be a rotation around the
+     * face, but could be a rotation to orient *to* that face, or a visiting of possible rotations.
+     * The method should return true if the rotation was successful though.
+     *
+     * @param world The world
+     * @param pos Block position in world
+     * @param axis The axis to rotate around
+     * @return True if the rotation was successful, False if the rotation failed, or is not possible
+     */
+    public boolean rotateBlock(World world, BlockPos pos, EnumFacing axis)
+    {
+        IBlockState state = world.getBlockState(pos);
+        for (IProperty prop : state.getProperties().keySet())
+        {
+            if (prop.getName().equals("shape"))
+            {
+                world.setBlockState(pos, state.cycleProperty(prop));
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /* ======================================== FORGE END =====================================*/
+
     public static enum EnumRailDirection implements IStringSerializable
     {
         NORTH_SOUTH(0, "north_south"),
@@ -215,7 +290,6 @@
             return this.meta;
         }
 
-        @Override
         public String toString()
         {
             return this.name;
@@ -236,7 +310,6 @@
             return META_LOOKUP[meta];
         }
 
-        @Override
         public String getName()
         {
             return this.name;
@@ -258,7 +331,8 @@
         private final BlockRailBase block;
         private IBlockState state;
         private final boolean isPowered;
-        private final List<BlockPos> connectedRails = Lists.newArrayList();
+        private final List<BlockPos> connectedRails = Lists.<BlockPos>newArrayList();
+        private final boolean canMakeSlopes;
 
         public Rail(World worldIn, BlockPos pos, IBlockState state)
         {
@@ -266,8 +340,9 @@
             this.pos = pos;
             this.state = state;
             this.block = (BlockRailBase)state.getBlock();
-            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = state.getValue(this.block.getShapeProperty());
-            this.isPowered = this.block.isPowered;
+            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = block.getRailDirection(worldIn, pos, state, null);
+            this.isPowered = !this.block.isFlexibleRail(worldIn, pos);
+            this.canMakeSlopes = this.block.canMakeSlopes(worldIn, pos);
             this.updateConnectedRails(blockrailbase$enumraildirection);
         }
 
@@ -326,7 +401,7 @@
 
         private void removeSoftConnections()
         {
-            for (int i = 0; i < this.connectedRails.size(); i++)
+            for (int i = 0; i < this.connectedRails.size(); ++i)
             {
                 BlockRailBase.Rail blockrailbase$rail = this.findRailAt(this.connectedRails.get(i));
 
@@ -343,9 +418,7 @@
 
         private boolean hasRailAt(BlockPos pos)
         {
-            return BlockRailBase.isRailBlock(this.world, pos)
-                   || BlockRailBase.isRailBlock(this.world, pos.up())
-                   || BlockRailBase.isRailBlock(this.world, pos.down());
+            return BlockRailBase.isRailBlock(this.world, pos) || BlockRailBase.isRailBlock(this.world, pos.up()) || BlockRailBase.isRailBlock(this.world, pos.down());
         }
 
         @Nullable
@@ -382,7 +455,7 @@
 
         private boolean isConnectedTo(BlockPos posIn)
         {
-            for (int i = 0; i < this.connectedRails.size(); i++)
+            for (int i = 0; i < this.connectedRails.size(); ++i)
             {
                 BlockPos blockpos = this.connectedRails.get(i);
 
@@ -403,7 +476,7 @@
             {
                 if (this.hasRailAt(this.pos.offset(enumfacing)))
                 {
-                    i++;
+                    ++i;
                 }
             }
 
@@ -461,7 +534,7 @@
                 }
             }
 
-            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.NORTH_SOUTH)
+            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.NORTH_SOUTH && canMakeSlopes)
             {
                 if (BlockRailBase.isRailBlock(this.world, blockpos.up()))
                 {
@@ -474,7 +547,7 @@
                 }
             }
 
-            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.EAST_WEST)
+            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.EAST_WEST && canMakeSlopes)
             {
                 if (BlockRailBase.isRailBlock(this.world, blockpos3.up()))
                 {
@@ -617,7 +690,7 @@
                 }
             }
 
-            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.NORTH_SOUTH)
+            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.NORTH_SOUTH && canMakeSlopes)
             {
                 if (BlockRailBase.isRailBlock(this.world, blockpos.up()))
                 {
@@ -630,7 +703,7 @@
                 }
             }
 
-            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.EAST_WEST)
+            if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.EAST_WEST && canMakeSlopes)
             {
                 if (BlockRailBase.isRailBlock(this.world, blockpos3.up()))
                 {
@@ -655,7 +728,7 @@
             {
                 this.world.setBlockState(this.pos, this.state, 3);
 
-                for (int i = 0; i < this.connectedRails.size(); i++)
+                for (int i = 0; i < this.connectedRails.size(); ++i)
                 {
                     BlockRailBase.Rail blockrailbase$rail = this.findRailAt(this.connectedRails.get(i));
 
