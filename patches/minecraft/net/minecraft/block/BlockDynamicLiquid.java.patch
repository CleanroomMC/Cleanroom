--- before/net/minecraft/block/BlockDynamicLiquid.java
+++ after/net/minecraft/block/BlockDynamicLiquid.java
@@ -21,15 +21,13 @@
 
     private void placeStaticBlock(World worldIn, BlockPos pos, IBlockState currentState)
     {
-        worldIn.setBlockState(
-            pos, getStaticBlock(this.material).getDefaultState().withProperty(LEVEL, currentState.getValue(LEVEL)), 2
-        );
+        worldIn.setBlockState(pos, getStaticBlock(this.material).getDefaultState().withProperty(LEVEL, currentState.getValue(LEVEL)), 2);
     }
 
-    @Override
     public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand)
     {
-        int i = state.getValue(LEVEL);
+        if (!worldIn.isAreaLoaded(pos, this.getSlopeFindDistance(worldIn))) return; // Forge: avoid loading unloaded chunks
+        int i = ((Integer)state.getValue(LEVEL)).intValue();
         int j = 1;
 
         if (this.material == Material.LAVA && !worldIn.provider.doesWaterVaporize())
@@ -70,7 +68,7 @@
                 }
             }
 
-            if (this.adjacentSourceBlocks >= 2 && this.material == Material.WATER)
+            if (this.adjacentSourceBlocks >= 2 && net.minecraftforge.event.ForgeEventFactory.canCreateFluidSource(worldIn, pos, state, this.material == Material.WATER))
             {
                 IBlockState iblockstate = worldIn.getBlockState(pos.down());
 
@@ -78,7 +76,7 @@
                 {
                     i1 = 0;
                 }
-                else if (iblockstate.getMaterial() == this.material && iblockstate.getValue(LEVEL) == 0)
+                else if (iblockstate.getMaterial() == this.material && ((Integer)iblockstate.getValue(LEVEL)).intValue() == 0)
                 {
                     i1 = 0;
                 }
@@ -103,7 +101,7 @@
                 }
                 else
                 {
-                    state = state.withProperty(LEVEL, i1);
+                    state = state.withProperty(LEVEL, Integer.valueOf(i1));
                     worldIn.setBlockState(pos, state, 2);
                     worldIn.scheduleUpdate(pos, this, k);
                     worldIn.notifyNeighborsOfStateChange(pos, this, false);
@@ -119,10 +117,9 @@
 
         if (this.canFlowInto(worldIn, pos.down(), iblockstate1))
         {
-            if (this.material == Material.LAVA
-                    && worldIn.getBlockState(pos.down()).getMaterial() == Material.WATER)
+            if (this.material == Material.LAVA && worldIn.getBlockState(pos.down()).getMaterial() == Material.WATER)
             {
-                worldIn.setBlockState(pos.down(), Blocks.STONE.getDefaultState());
+                worldIn.setBlockState(pos.down(), net.minecraftforge.event.ForgeEventFactory.fireFluidPlaceBlockEvent(worldIn, pos.down(), pos, Blocks.STONE.getDefaultState()));
                 this.triggerMixEffects(worldIn, pos.down());
                 return;
             }
@@ -170,11 +167,12 @@
                 }
                 else
                 {
+                    if (state.getBlock() != Blocks.SNOW_LAYER) //Forge: Vanilla has a 'bug' where snowballs don't drop like every other block. So special case because ewww...
                     state.getBlock().dropBlockAsItem(worldIn, pos, state, 0);
                 }
             }
 
-            worldIn.setBlockState(pos, this.getDefaultState().withProperty(LEVEL, level), 3);
+            worldIn.setBlockState(pos, this.getDefaultState().withProperty(LEVEL, Integer.valueOf(level)), 3);
         }
     }
 
@@ -189,10 +187,9 @@
                 BlockPos blockpos = pos.offset(enumfacing);
                 IBlockState iblockstate = worldIn.getBlockState(blockpos);
 
-                if (!this.isBlocked(worldIn, blockpos, iblockstate)
-                        && (iblockstate.getMaterial() != this.material || iblockstate.getValue(LEVEL) > 0))
+                if (!this.isBlocked(worldIn, blockpos, iblockstate) && (iblockstate.getMaterial() != this.material || ((Integer)iblockstate.getValue(LEVEL)).intValue() > 0))
                 {
-                    if (!this.isBlocked(worldIn, blockpos.down(), iblockstate))
+                    if (!this.isBlocked(worldIn, blockpos.down(), worldIn.getBlockState(blockpos.down())))
                     {
                         return distance;
                     }
@@ -221,15 +218,14 @@
     private Set<EnumFacing> getPossibleFlowDirections(World worldIn, BlockPos pos)
     {
         int i = 1000;
-        Set<EnumFacing> set = EnumSet.noneOf(EnumFacing.class);
+        Set<EnumFacing> set = EnumSet.<EnumFacing>noneOf(EnumFacing.class);
 
         for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
         {
             BlockPos blockpos = pos.offset(enumfacing);
             IBlockState iblockstate = worldIn.getBlockState(blockpos);
 
-            if (!this.isBlocked(worldIn, blockpos, iblockstate)
-                    && (iblockstate.getMaterial() != this.material || iblockstate.getValue(LEVEL) > 0))
+            if (!this.isBlocked(worldIn, blockpos, iblockstate) && (iblockstate.getMaterial() != this.material || ((Integer)iblockstate.getValue(LEVEL)).intValue() > 0))
             {
                 int j;
 
@@ -260,16 +256,17 @@
 
     private boolean isBlocked(World worldIn, BlockPos pos, IBlockState state)
     {
-        Block block = worldIn.getBlockState(pos).getBlock();
+        Block block = state.getBlock(); //Forge: state must be valid for position
+        Material mat = state.getMaterial();
 
-        if (block instanceof BlockDoor || block == Blocks.STANDING_SIGN || block == Blocks.LADDER || block == Blocks.REEDS)
+        if (!(block instanceof BlockDoor) && block != Blocks.STANDING_SIGN && block != Blocks.LADDER && block != Blocks.REEDS)
+        {
+            return mat != Material.PORTAL && mat != Material.STRUCTURE_VOID ? mat.blocksMovement() : true;
+        }
+        else
         {
             return true;
         }
-        else
-        {
-            return block.material != Material.PORTAL && block.material != Material.STRUCTURE_VOID ? block.material.blocksMovement() : true;
-        }
     }
 
     protected int checkAdjacentBlock(World worldIn, BlockPos pos, int currentMinLevel)
@@ -284,7 +281,7 @@
         {
             if (i == 0)
             {
-                this.adjacentSourceBlocks++;
+                ++this.adjacentSourceBlocks;
             }
 
             if (i >= 8)
@@ -302,7 +299,6 @@
         return material != this.material && material != Material.LAVA && !this.isBlocked(worldIn, pos, state);
     }
 
-    @Override
     public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state)
     {
         if (!this.checkForMixing(worldIn, pos, state))
