--- before/net/minecraft/block/BlockStairs.java
+++ after/net/minecraft/block/BlockStairs.java
@@ -5,6 +5,7 @@
 import java.util.Random;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.MapColor;
+import net.minecraft.block.properties.IProperty;
 import net.minecraft.block.properties.PropertyDirection;
 import net.minecraft.block.properties.PropertyEnum;
 import net.minecraft.block.state.BlockFaceShape;
@@ -34,39 +35,33 @@
 public class BlockStairs extends Block
 {
     public static final PropertyDirection FACING = BlockHorizontal.FACING;
-    public static final PropertyEnum<BlockStairs.EnumHalf> HALF = PropertyEnum.create("half", BlockStairs.EnumHalf.class);
-    public static final PropertyEnum<BlockStairs.EnumShape> SHAPE = PropertyEnum.create("shape", BlockStairs.EnumShape.class);
-    protected static final AxisAlignedBB AABB_SLAB_TOP = new AxisAlignedBB(0.0, 0.5, 0.0, 1.0, 1.0, 1.0);
-    protected static final AxisAlignedBB AABB_QTR_TOP_WEST = new AxisAlignedBB(0.0, 0.5, 0.0, 0.5, 1.0, 1.0);
-    protected static final AxisAlignedBB AABB_QTR_TOP_EAST = new AxisAlignedBB(0.5, 0.5, 0.0, 1.0, 1.0, 1.0);
-    protected static final AxisAlignedBB AABB_QTR_TOP_NORTH = new AxisAlignedBB(0.0, 0.5, 0.0, 1.0, 1.0, 0.5);
-    protected static final AxisAlignedBB AABB_QTR_TOP_SOUTH = new AxisAlignedBB(0.0, 0.5, 0.5, 1.0, 1.0, 1.0);
-    protected static final AxisAlignedBB AABB_OCT_TOP_NW = new AxisAlignedBB(0.0, 0.5, 0.0, 0.5, 1.0, 0.5);
-    protected static final AxisAlignedBB AABB_OCT_TOP_NE = new AxisAlignedBB(0.5, 0.5, 0.0, 1.0, 1.0, 0.5);
-    protected static final AxisAlignedBB AABB_OCT_TOP_SW = new AxisAlignedBB(0.0, 0.5, 0.5, 0.5, 1.0, 1.0);
-    protected static final AxisAlignedBB AABB_OCT_TOP_SE = new AxisAlignedBB(0.5, 0.5, 0.5, 1.0, 1.0, 1.0);
-    protected static final AxisAlignedBB AABB_SLAB_BOTTOM = new AxisAlignedBB(0.0, 0.0, 0.0, 1.0, 0.5, 1.0);
-    protected static final AxisAlignedBB AABB_QTR_BOT_WEST = new AxisAlignedBB(0.0, 0.0, 0.0, 0.5, 0.5, 1.0);
-    protected static final AxisAlignedBB AABB_QTR_BOT_EAST = new AxisAlignedBB(0.5, 0.0, 0.0, 1.0, 0.5, 1.0);
-    protected static final AxisAlignedBB AABB_QTR_BOT_NORTH = new AxisAlignedBB(0.0, 0.0, 0.0, 1.0, 0.5, 0.5);
-    protected static final AxisAlignedBB AABB_QTR_BOT_SOUTH = new AxisAlignedBB(0.0, 0.0, 0.5, 1.0, 0.5, 1.0);
-    protected static final AxisAlignedBB AABB_OCT_BOT_NW = new AxisAlignedBB(0.0, 0.0, 0.0, 0.5, 0.5, 0.5);
-    protected static final AxisAlignedBB AABB_OCT_BOT_NE = new AxisAlignedBB(0.5, 0.0, 0.0, 1.0, 0.5, 0.5);
-    protected static final AxisAlignedBB AABB_OCT_BOT_SW = new AxisAlignedBB(0.0, 0.0, 0.5, 0.5, 0.5, 1.0);
-    protected static final AxisAlignedBB AABB_OCT_BOT_SE = new AxisAlignedBB(0.5, 0.0, 0.5, 1.0, 0.5, 1.0);
+    public static final PropertyEnum<BlockStairs.EnumHalf> HALF = PropertyEnum.<BlockStairs.EnumHalf>create("half", BlockStairs.EnumHalf.class);
+    public static final PropertyEnum<BlockStairs.EnumShape> SHAPE = PropertyEnum.<BlockStairs.EnumShape>create("shape", BlockStairs.EnumShape.class);
+    protected static final AxisAlignedBB AABB_SLAB_TOP = new AxisAlignedBB(0.0D, 0.5D, 0.0D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_QTR_TOP_WEST = new AxisAlignedBB(0.0D, 0.5D, 0.0D, 0.5D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_QTR_TOP_EAST = new AxisAlignedBB(0.5D, 0.5D, 0.0D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_QTR_TOP_NORTH = new AxisAlignedBB(0.0D, 0.5D, 0.0D, 1.0D, 1.0D, 0.5D);
+    protected static final AxisAlignedBB AABB_QTR_TOP_SOUTH = new AxisAlignedBB(0.0D, 0.5D, 0.5D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_OCT_TOP_NW = new AxisAlignedBB(0.0D, 0.5D, 0.0D, 0.5D, 1.0D, 0.5D);
+    protected static final AxisAlignedBB AABB_OCT_TOP_NE = new AxisAlignedBB(0.5D, 0.5D, 0.0D, 1.0D, 1.0D, 0.5D);
+    protected static final AxisAlignedBB AABB_OCT_TOP_SW = new AxisAlignedBB(0.0D, 0.5D, 0.5D, 0.5D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_OCT_TOP_SE = new AxisAlignedBB(0.5D, 0.5D, 0.5D, 1.0D, 1.0D, 1.0D);
+    protected static final AxisAlignedBB AABB_SLAB_BOTTOM = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.5D, 1.0D);
+    protected static final AxisAlignedBB AABB_QTR_BOT_WEST = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.5D, 0.5D, 1.0D);
+    protected static final AxisAlignedBB AABB_QTR_BOT_EAST = new AxisAlignedBB(0.5D, 0.0D, 0.0D, 1.0D, 0.5D, 1.0D);
+    protected static final AxisAlignedBB AABB_QTR_BOT_NORTH = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.5D, 0.5D);
+    protected static final AxisAlignedBB AABB_QTR_BOT_SOUTH = new AxisAlignedBB(0.0D, 0.0D, 0.5D, 1.0D, 0.5D, 1.0D);
+    protected static final AxisAlignedBB AABB_OCT_BOT_NW = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.5D, 0.5D, 0.5D);
+    protected static final AxisAlignedBB AABB_OCT_BOT_NE = new AxisAlignedBB(0.5D, 0.0D, 0.0D, 1.0D, 0.5D, 0.5D);
+    protected static final AxisAlignedBB AABB_OCT_BOT_SW = new AxisAlignedBB(0.0D, 0.0D, 0.5D, 0.5D, 0.5D, 1.0D);
+    protected static final AxisAlignedBB AABB_OCT_BOT_SE = new AxisAlignedBB(0.5D, 0.0D, 0.5D, 1.0D, 0.5D, 1.0D);
     private final Block modelBlock;
     private final IBlockState modelState;
 
     protected BlockStairs(IBlockState modelState)
     {
         super(modelState.getBlock().material);
-        this.setDefaultState(
-            this.blockState
-            .getBaseState()
-            .withProperty(FACING, EnumFacing.NORTH)
-            .withProperty(HALF, BlockStairs.EnumHalf.BOTTOM)
-            .withProperty(SHAPE, BlockStairs.EnumShape.STRAIGHT)
-        );
+        this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH).withProperty(HALF, BlockStairs.EnumHalf.BOTTOM).withProperty(SHAPE, BlockStairs.EnumShape.STRAIGHT));
         this.modelBlock = modelState.getBlock();
         this.modelState = modelState;
         this.setHardness(this.modelBlock.blockHardness);
@@ -76,16 +71,7 @@
         this.setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
     }
 
-    @Override
-    public void addCollisionBoxToList(
-        IBlockState state,
-        World worldIn,
-        BlockPos pos,
-        AxisAlignedBB entityBox,
-        List<AxisAlignedBB> collidingBoxes,
-        @Nullable Entity entityIn,
-        boolean isActualState
-    )
+    public void addCollisionBoxToList(IBlockState state, World worldIn, BlockPos pos, AxisAlignedBB entityBox, List<AxisAlignedBB> collidingBoxes, @Nullable Entity entityIn, boolean isActualState)
     {
         if (!isActualState)
         {
@@ -100,14 +86,12 @@
 
     private static List<AxisAlignedBB> getCollisionBoxList(IBlockState bstate)
     {
-        List<AxisAlignedBB> list = Lists.newArrayList();
+        List<AxisAlignedBB> list = Lists.<AxisAlignedBB>newArrayList();
         boolean flag = bstate.getValue(HALF) == BlockStairs.EnumHalf.TOP;
         list.add(flag ? AABB_SLAB_TOP : AABB_SLAB_BOTTOM);
-        BlockStairs.EnumShape blockstairs$enumshape = bstate.getValue(SHAPE);
+        BlockStairs.EnumShape blockstairs$enumshape = (BlockStairs.EnumShape)bstate.getValue(SHAPE);
 
-        if (blockstairs$enumshape == BlockStairs.EnumShape.STRAIGHT
-                || blockstairs$enumshape == BlockStairs.EnumShape.INNER_LEFT
-                || blockstairs$enumshape == BlockStairs.EnumShape.INNER_RIGHT)
+        if (blockstairs$enumshape == BlockStairs.EnumShape.STRAIGHT || blockstairs$enumshape == BlockStairs.EnumShape.INNER_LEFT || blockstairs$enumshape == BlockStairs.EnumShape.INNER_RIGHT)
         {
             list.add(getCollQuarterBlock(bstate));
         }
@@ -140,7 +124,7 @@
 
     private static AxisAlignedBB getCollEighthBlock(IBlockState bstate)
     {
-        EnumFacing enumfacing = bstate.getValue(FACING);
+        EnumFacing enumfacing = (EnumFacing)bstate.getValue(FACING);
         EnumFacing enumfacing1;
 
         switch ((BlockStairs.EnumShape)bstate.getValue(SHAPE))
@@ -175,24 +159,21 @@
         }
     }
 
-    @Override
     public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face)
     {
         state = this.getActualState(state, worldIn, pos);
 
         if (face.getAxis() == EnumFacing.Axis.Y)
         {
-            return face == EnumFacing.UP == (state.getValue(HALF) == BlockStairs.EnumHalf.TOP)
-                   ? BlockFaceShape.SOLID
-                   : BlockFaceShape.UNDEFINED;
+            return face == EnumFacing.UP == (state.getValue(HALF) == BlockStairs.EnumHalf.TOP) ? BlockFaceShape.SOLID : BlockFaceShape.UNDEFINED;
         }
         else
         {
-            BlockStairs.EnumShape blockstairs$enumshape = state.getValue(SHAPE);
+            BlockStairs.EnumShape blockstairs$enumshape = (BlockStairs.EnumShape)state.getValue(SHAPE);
 
             if (blockstairs$enumshape != BlockStairs.EnumShape.OUTER_LEFT && blockstairs$enumshape != BlockStairs.EnumShape.OUTER_RIGHT)
             {
-                EnumFacing enumfacing = state.getValue(FACING);
+                EnumFacing enumfacing = (EnumFacing)state.getValue(FACING);
 
                 switch (blockstairs$enumshape)
                 {
@@ -213,177 +194,132 @@
         }
     }
 
-    @Override
     public boolean isOpaqueCube(IBlockState state)
     {
         return false;
     }
 
-    @Override
     public boolean isFullCube(IBlockState state)
     {
         return false;
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand)
     {
         this.modelBlock.randomDisplayTick(stateIn, worldIn, pos, rand);
     }
 
-    @Override
     public void onBlockClicked(World worldIn, BlockPos pos, EntityPlayer playerIn)
     {
         this.modelBlock.onBlockClicked(worldIn, pos, playerIn);
     }
 
-    @Override
     public void onPlayerDestroy(World worldIn, BlockPos pos, IBlockState state)
     {
         this.modelBlock.onPlayerDestroy(worldIn, pos, state);
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos)
     {
         return this.modelState.getPackedLightmapCoords(source, pos);
     }
 
-    @Override
     public float getExplosionResistance(Entity exploder)
     {
         return this.modelBlock.getExplosionResistance(exploder);
     }
 
-    @SideOnly(Side.CLIENT)
-    @Override
-    public BlockRenderLayer getRenderLayer()
-    {
-        return this.modelBlock.getRenderLayer();
-    }
-
-    @Override
     public int tickRate(World worldIn)
     {
         return this.modelBlock.tickRate(worldIn);
     }
 
-    @SideOnly(Side.CLIENT)
-    @Override
-    public AxisAlignedBB getSelectedBoundingBox(IBlockState state, World worldIn, BlockPos pos)
-    {
-        return this.modelState.getSelectedBoundingBox(worldIn, pos);
-    }
-
-    @Override
     public Vec3d modifyAcceleration(World worldIn, BlockPos pos, Entity entityIn, Vec3d motion)
     {
         return this.modelBlock.modifyAcceleration(worldIn, pos, entityIn, motion);
     }
 
-    @Override
+    @SideOnly(Side.CLIENT)
+    public BlockRenderLayer getRenderLayer()
+    {
+        return this.modelBlock.getRenderLayer();
+    }
+
+    @SideOnly(Side.CLIENT)
+    public AxisAlignedBB getSelectedBoundingBox(IBlockState state, World worldIn, BlockPos pos)
+    {
+        return this.modelState.getSelectedBoundingBox(worldIn, pos);
+    }
+
     public boolean isCollidable()
     {
         return this.modelBlock.isCollidable();
     }
 
-    @Override
     public boolean canCollideCheck(IBlockState state, boolean hitIfLiquid)
     {
         return this.modelBlock.canCollideCheck(state, hitIfLiquid);
     }
 
-    @Override
     public boolean canPlaceBlockAt(World worldIn, BlockPos pos)
     {
         return this.modelBlock.canPlaceBlockAt(worldIn, pos);
     }
 
-    @Override
     public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state)
     {
         this.modelState.neighborChanged(worldIn, pos, Blocks.AIR, pos);
         this.modelBlock.onBlockAdded(worldIn, pos, this.modelState);
     }
 
-    @Override
     public void breakBlock(World worldIn, BlockPos pos, IBlockState state)
     {
         this.modelBlock.breakBlock(worldIn, pos, this.modelState);
     }
 
-    @Override
     public void onEntityWalk(World worldIn, BlockPos pos, Entity entityIn)
     {
         this.modelBlock.onEntityWalk(worldIn, pos, entityIn);
     }
 
-    @Override
     public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand)
     {
         this.modelBlock.updateTick(worldIn, pos, state, rand);
     }
 
-    @Override
-    public boolean onBlockActivated(
-        World worldIn,
-        BlockPos pos,
-        IBlockState state,
-        EntityPlayer playerIn,
-        EnumHand hand,
-        EnumFacing facing,
-        float hitX,
-        float hitY,
-        float hitZ
-    )
+    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
     {
         return this.modelBlock.onBlockActivated(worldIn, pos, this.modelState, playerIn, hand, EnumFacing.DOWN, 0.0F, 0.0F, 0.0F);
     }
 
-    @Override
     public void onExplosionDestroy(World worldIn, BlockPos pos, Explosion explosionIn)
     {
         this.modelBlock.onExplosionDestroy(worldIn, pos, explosionIn);
     }
 
-    @Override
     public boolean isTopSolid(IBlockState state)
     {
         return state.getValue(HALF) == BlockStairs.EnumHalf.TOP;
     }
 
-    @Override
     public MapColor getMapColor(IBlockState state, IBlockAccess worldIn, BlockPos pos)
     {
         return this.modelBlock.getMapColor(this.modelState, worldIn, pos);
     }
 
-    @Override
-    public IBlockState getStateForPlacement(
-        World worldIn,
-        BlockPos pos,
-        EnumFacing facing,
-        float hitX,
-        float hitY,
-        float hitZ,
-        int meta,
-        EntityLivingBase placer
-    )
+    public IBlockState getStateForPlacement(World worldIn, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer)
     {
         IBlockState iblockstate = super.getStateForPlacement(worldIn, pos, facing, hitX, hitY, hitZ, meta, placer);
         iblockstate = iblockstate.withProperty(FACING, placer.getHorizontalFacing()).withProperty(SHAPE, BlockStairs.EnumShape.STRAIGHT);
-        return facing != EnumFacing.DOWN && (facing == EnumFacing.UP || !((double)hitY > 0.5))
-               ? iblockstate.withProperty(HALF, BlockStairs.EnumHalf.BOTTOM)
-               : iblockstate.withProperty(HALF, BlockStairs.EnumHalf.TOP);
+        return facing != EnumFacing.DOWN && (facing == EnumFacing.UP || (double)hitY <= 0.5D) ? iblockstate.withProperty(HALF, BlockStairs.EnumHalf.BOTTOM) : iblockstate.withProperty(HALF, BlockStairs.EnumHalf.TOP);
     }
 
     @Nullable
-    @Override
     public RayTraceResult collisionRayTrace(IBlockState blockState, World worldIn, BlockPos pos, Vec3d start, Vec3d end)
     {
-        List<RayTraceResult> list = Lists.newArrayList();
+        List<RayTraceResult> list = Lists.<RayTraceResult>newArrayList();
 
         for (AxisAlignedBB axisalignedbb : getCollisionBoxList(this.getActualState(blockState, worldIn, pos)))
         {
@@ -391,7 +327,7 @@
         }
 
         RayTraceResult raytraceresult1 = null;
-        double d1 = 0.0;
+        double d1 = 0.0D;
 
         for (RayTraceResult raytraceresult : list)
         {
@@ -410,15 +346,13 @@
         return raytraceresult1;
     }
 
-    @Override
     public IBlockState getStateFromMeta(int meta)
     {
-        IBlockState iblockstate = this.getDefaultState()
-                                  .withProperty(HALF, (meta & 4) > 0 ? BlockStairs.EnumHalf.TOP : BlockStairs.EnumHalf.BOTTOM);
-        return iblockstate.withProperty(FACING, EnumFacing.byIndex(5 - (meta & 3)));
+        IBlockState iblockstate = this.getDefaultState().withProperty(HALF, (meta & 4) > 0 ? BlockStairs.EnumHalf.TOP : BlockStairs.EnumHalf.BOTTOM);
+        iblockstate = iblockstate.withProperty(FACING, EnumFacing.byIndex(5 - (meta & 3)));
+        return iblockstate;
     }
 
-    @Override
     public int getMetaFromState(IBlockState state)
     {
         int i = 0;
@@ -428,10 +362,10 @@
             i |= 4;
         }
 
-        return i | 5 - state.getValue(FACING).getIndex();
+        i = i | 5 - ((EnumFacing)state.getValue(FACING)).getIndex();
+        return i;
     }
 
-    @Override
     public IBlockState getActualState(IBlockState state, IBlockAccess worldIn, BlockPos pos)
     {
         return state.withProperty(SHAPE, getStairsShape(state, worldIn, pos));
@@ -439,15 +373,14 @@
 
     private static BlockStairs.EnumShape getStairsShape(IBlockState p_185706_0_, IBlockAccess p_185706_1_, BlockPos p_185706_2_)
     {
-        EnumFacing enumfacing = p_185706_0_.getValue(FACING);
+        EnumFacing enumfacing = (EnumFacing)p_185706_0_.getValue(FACING);
         IBlockState iblockstate = p_185706_1_.getBlockState(p_185706_2_.offset(enumfacing));
 
         if (isBlockStairs(iblockstate) && p_185706_0_.getValue(HALF) == iblockstate.getValue(HALF))
         {
-            EnumFacing enumfacing1 = iblockstate.getValue(FACING);
+            EnumFacing enumfacing1 = (EnumFacing)iblockstate.getValue(FACING);
 
-            if (enumfacing1.getAxis() != p_185706_0_.getValue(FACING).getAxis()
-                    && isDifferentStairs(p_185706_0_, p_185706_1_, p_185706_2_, enumfacing1.getOpposite()))
+            if (enumfacing1.getAxis() != ((EnumFacing)p_185706_0_.getValue(FACING)).getAxis() && isDifferentStairs(p_185706_0_, p_185706_1_, p_185706_2_, enumfacing1.getOpposite()))
             {
                 if (enumfacing1 == enumfacing.rotateYCCW())
                 {
@@ -462,10 +395,9 @@
 
         if (isBlockStairs(iblockstate1) && p_185706_0_.getValue(HALF) == iblockstate1.getValue(HALF))
         {
-            EnumFacing enumfacing2 = iblockstate1.getValue(FACING);
+            EnumFacing enumfacing2 = (EnumFacing)iblockstate1.getValue(FACING);
 
-            if (enumfacing2.getAxis() != p_185706_0_.getValue(FACING).getAxis()
-                    && isDifferentStairs(p_185706_0_, p_185706_1_, p_185706_2_, enumfacing2))
+            if (enumfacing2.getAxis() != ((EnumFacing)p_185706_0_.getValue(FACING)).getAxis() && isDifferentStairs(p_185706_0_, p_185706_1_, p_185706_2_, enumfacing2))
             {
                 if (enumfacing2 == enumfacing.rotateYCCW())
                 {
@@ -482,9 +414,7 @@
     private static boolean isDifferentStairs(IBlockState p_185704_0_, IBlockAccess p_185704_1_, BlockPos p_185704_2_, EnumFacing p_185704_3_)
     {
         IBlockState iblockstate = p_185704_1_.getBlockState(p_185704_2_.offset(p_185704_3_));
-        return !isBlockStairs(iblockstate)
-               || iblockstate.getValue(FACING) != p_185704_0_.getValue(FACING)
-               || iblockstate.getValue(HALF) != p_185704_0_.getValue(HALF);
+        return !isBlockStairs(iblockstate) || iblockstate.getValue(FACING) != p_185704_0_.getValue(FACING) || iblockstate.getValue(HALF) != p_185704_0_.getValue(HALF);
     }
 
     public static boolean isBlockStairs(IBlockState state)
@@ -492,18 +422,16 @@
         return state.getBlock() instanceof BlockStairs;
     }
 
-    @Override
     public IBlockState withRotation(IBlockState state, Rotation rot)
     {
-        return state.withProperty(FACING, rot.rotate(state.getValue(FACING)));
+        return state.withProperty(FACING, rot.rotate((EnumFacing)state.getValue(FACING)));
     }
 
     @SuppressWarnings("incomplete-switch")
-    @Override
     public IBlockState withMirror(IBlockState state, Mirror mirrorIn)
     {
-        EnumFacing enumfacing = state.getValue(FACING);
-        BlockStairs.EnumShape blockstairs$enumshape = state.getValue(SHAPE);
+        EnumFacing enumfacing = (EnumFacing)state.getValue(FACING);
+        BlockStairs.EnumShape blockstairs$enumshape = (BlockStairs.EnumShape)state.getValue(SHAPE);
 
         switch (mirrorIn)
         {
@@ -550,10 +478,32 @@
         return super.withMirror(state, mirrorIn);
     }
 
-    @Override
     protected BlockStateContainer createBlockState()
     {
-        return new BlockStateContainer(this, FACING, HALF, SHAPE);
+        return new BlockStateContainer(this, new IProperty[] {FACING, HALF, SHAPE});
+    }
+
+    @Override
+    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face)
+    {
+        if (net.minecraftforge.common.ForgeModContainer.disableStairSlabCulling)
+            return super.doesSideBlockRendering(state, world, pos, face);
+
+        if ( state.isOpaqueCube() )
+            return true;
+
+        state = this.getActualState(state, world, pos);
+
+        EnumHalf half = state.getValue(HALF);
+        EnumFacing side = state.getValue(FACING);
+        EnumShape shape = state.getValue(SHAPE);
+        if (face == EnumFacing.UP) return half == EnumHalf.TOP;
+        if (face == EnumFacing.DOWN) return half == EnumHalf.BOTTOM;
+        if (shape == EnumShape.OUTER_LEFT || shape == EnumShape.OUTER_RIGHT) return false;
+        if (face == side) return true;
+        if (shape == EnumShape.INNER_LEFT && face.rotateY() == side) return true;
+        if (shape == EnumShape.INNER_RIGHT && face.rotateYCCW() == side) return true;
+        return false;
     }
 
     public static enum EnumHalf implements IStringSerializable
@@ -568,13 +518,11 @@
             this.name = name;
         }
 
-        @Override
         public String toString()
         {
             return this.name;
         }
 
-        @Override
         public String getName()
         {
             return this.name;
@@ -596,13 +544,11 @@
             this.name = name;
         }
 
-        @Override
         public String toString()
         {
             return this.name;
         }
 
-        @Override
         public String getName()
         {
             return this.name;
