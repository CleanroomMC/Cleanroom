--- before/net/minecraft/world/gen/feature/WorldGenBigTree.java
+++ after/net/minecraft/world/gen/feature/WorldGenBigTree.java
@@ -20,10 +20,10 @@
     private BlockPos basePos = BlockPos.ORIGIN;
     int heightLimit;
     int height;
-    double heightAttenuation = 0.618;
-    double branchSlope = 0.381;
-    double scaleWidth = 1.0;
-    double leafDensity = 1.0;
+    double heightAttenuation = 0.618D;
+    double branchSlope = 0.381D;
+    double scaleWidth = 1.0D;
+    double leafDensity = 1.0D;
     int trunkSize = 1;
     int heightLimitLimit = 12;
     int leafDistanceLimit = 4;
@@ -43,7 +43,7 @@
             this.height = this.heightLimit - 1;
         }
 
-        int i = (int)(1.382 + Math.pow(this.leafDensity * (double)this.heightLimit / 13.0, 2.0));
+        int i = (int)(1.382D + Math.pow(this.leafDensity * (double)this.heightLimit / 13.0D, 2.0D));
 
         if (i < 1)
         {
@@ -52,21 +52,21 @@
 
         int j = this.basePos.getY() + this.height;
         int k = this.heightLimit - this.leafDistanceLimit;
-        this.foliageCoords = Lists.newArrayList();
+        this.foliageCoords = Lists.<WorldGenBigTree.FoliageCoordinates>newArrayList();
         this.foliageCoords.add(new WorldGenBigTree.FoliageCoordinates(this.basePos.up(k), j));
 
-        for (; k >= 0; k--)
+        for (; k >= 0; --k)
         {
             float f = this.layerSize(k);
 
-            if (!(f < 0.0F))
+            if (f >= 0.0F)
             {
-                for (int l = 0; l < i; l++)
+                for (int l = 0; l < i; ++l)
                 {
-                    double d0 = this.scaleWidth * (double)f * ((double)this.rand.nextFloat() + 0.328);
+                    double d0 = this.scaleWidth * (double)f * ((double)this.rand.nextFloat() + 0.328D);
                     double d1 = (double)(this.rand.nextFloat() * 2.0F) * Math.PI;
-                    double d2 = d0 * Math.sin(d1) + 0.5;
-                    double d3 = d0 * Math.cos(d1) + 0.5;
+                    double d2 = d0 * Math.sin(d1) + 0.5D;
+                    double d3 = d0 * Math.cos(d1) + 0.5D;
                     BlockPos blockpos = this.basePos.add(d2, (double)(k - 1), d3);
                     BlockPos blockpos1 = blockpos.up(this.leafDistanceLimit);
 
@@ -90,18 +90,18 @@
 
     void crosSection(BlockPos pos, float p_181631_2_, IBlockState p_181631_3_)
     {
-        int i = (int)((double)p_181631_2_ + 0.618);
+        int i = (int)((double)p_181631_2_ + 0.618D);
 
-        for (int j = -i; j <= i; j++)
+        for (int j = -i; j <= i; ++j)
         {
-            for (int k = -i; k <= i; k++)
+            for (int k = -i; k <= i; ++k)
             {
-                if (Math.pow((double)Math.abs(j) + 0.5, 2.0) + Math.pow((double)Math.abs(k) + 0.5, 2.0) <= (double)(p_181631_2_ * p_181631_2_))
+                if (Math.pow((double)Math.abs(j) + 0.5D, 2.0D) + Math.pow((double)Math.abs(k) + 0.5D, 2.0D) <= (double)(p_181631_2_ * p_181631_2_))
                 {
                     BlockPos blockpos = pos.add(j, 0, k);
-                    Material material = this.world.getBlockState(blockpos).getMaterial();
+                    IBlockState state = this.world.getBlockState(blockpos);
 
-                    if (material == Material.AIR || material == Material.LEAVES)
+                    if (state.getBlock().isAir(state, world, blockpos) || state.getBlock().isLeaves(state, world, blockpos))
                     {
                         this.setBlockAndNotifyAdequately(this.world, blockpos, p_181631_3_);
                     }
@@ -137,23 +137,21 @@
 
     float leafSize(int y)
     {
-        if (y < 0 || y >= this.leafDistanceLimit)
-        {
-            return -1.0F;
-        }
-        else
+        if (y >= 0 && y < this.leafDistanceLimit)
         {
             return y != 0 && y != this.leafDistanceLimit - 1 ? 3.0F : 2.0F;
         }
+        else
+        {
+            return -1.0F;
+        }
     }
 
     void generateLeafNode(BlockPos pos)
     {
-        for (int i = 0; i < this.leafDistanceLimit; i++)
+        for (int i = 0; i < this.leafDistanceLimit; ++i)
         {
-            this.crosSection(
-                pos.up(i), this.leafSize(i), Blocks.LEAVES.getDefaultState().withProperty(BlockLeaves.CHECK_DECAY, false)
-            );
+            this.crosSection(pos.up(i), this.leafSize(i), Blocks.LEAVES.getDefaultState().withProperty(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false)));
         }
     }
 
@@ -165,7 +163,7 @@
         float f1 = (float)blockpos.getY() / (float)i;
         float f2 = (float)blockpos.getZ() / (float)i;
 
-        for (int j = 0; j <= i; j++)
+        for (int j = 0; j <= i; ++j)
         {
             BlockPos blockpos1 = p_175937_1_.add((double)(0.5F + (float)j * f), (double)(0.5F + (float)j * f1), (double)(0.5F + (float)j * f2));
             BlockLog.EnumAxis blocklog$enumaxis = this.getLogAxis(p_175937_1_, blockpos1);
@@ -221,7 +219,7 @@
 
     boolean leafNodeNeedsBase(int p_76493_1_)
     {
-        return (double)p_76493_1_ >= (double)this.heightLimit * 0.2;
+        return (double)p_76493_1_ >= (double)this.heightLimit * 0.2D;
     }
 
     void generateTrunk()
@@ -267,11 +265,11 @@
         }
         else
         {
-            for (int j = 0; j <= i; j++)
+            for (int j = 0; j <= i; ++j)
             {
                 BlockPos blockpos1 = posOne.add((double)(0.5F + (float)j * f), (double)(0.5F + (float)j * f1), (double)(0.5F + (float)j * f2));
 
-                if (!this.canGrowInto(this.world.getBlockState(blockpos1).getBlock()))
+                if (!this.isReplaceable(world, blockpos1))
                 {
                     return j;
                 }
@@ -281,13 +279,11 @@
         }
     }
 
-    @Override
     public void setDecorationDefaults()
     {
         this.leafDistanceLimit = 5;
     }
 
-    @Override
     public boolean generate(World worldIn, Random rand, BlockPos position)
     {
         this.world = worldIn;
@@ -301,6 +297,7 @@
 
         if (!this.validTreeLocation())
         {
+            this.world = null; //Fix vanilla Mem leak, holds latest world
             return false;
         }
         else
@@ -309,15 +306,18 @@
             this.generateLeaves();
             this.generateTrunk();
             this.generateLeafNodeBases();
+            this.world = null; //Fix vanilla Mem leak, holds latest world
             return true;
         }
     }
 
     private boolean validTreeLocation()
     {
-        Block block = this.world.getBlockState(this.basePos.down()).getBlock();
+        BlockPos down = this.basePos.down();
+        net.minecraft.block.state.IBlockState state = this.world.getBlockState(down);
+        boolean isSoil = state.getBlock().canSustainPlant(state, this.world, down, net.minecraft.util.EnumFacing.UP, ((net.minecraft.block.BlockSapling)Blocks.SAPLING));
 
-        if (block != Blocks.DIRT && block != Blocks.GRASS && block != Blocks.FARMLAND)
+        if (!isSoil)
         {
             return false;
         }
