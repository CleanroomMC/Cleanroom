--- before/net/minecraft/world/gen/structure/MapGenStructure.java
+++ after/net/minecraft/world/gen/structure/MapGenStructure.java
@@ -2,6 +2,8 @@
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import java.util.Iterator;
 import java.util.Random;
 import javax.annotation.Nullable;
 import net.minecraft.crash.CrashReport;
@@ -19,15 +21,11 @@
 public abstract class MapGenStructure extends MapGenBase
 {
     private MapGenStructureData structureData;
-    protected Long2ObjectMap<StructureStart> structureMap = new Long2ObjectOpenHashMap<>(1024);
+    protected Long2ObjectMap<StructureStart> structureMap = new Long2ObjectOpenHashMap<StructureStart>(1024);
 
     public abstract String getStructureName();
 
-    @Override
-
-    protected final synchronized void recursiveGenerate(
-        World worldIn, final int chunkX, final int chunkZ, int originalX, int originalZ, ChunkPrimer chunkPrimerIn
-    )
+    protected final synchronized void recursiveGenerate(World worldIn, final int chunkX, final int chunkZ, int originalX, int originalZ, ChunkPrimer chunkPrimerIn)
     {
         this.initializeStructureData(worldIn);
 
@@ -85,9 +83,12 @@
         int i = (chunkCoord.x << 4) + 8;
         int j = (chunkCoord.z << 4) + 8;
         boolean flag = false;
+        ObjectIterator objectiterator = this.structureMap.values().iterator();
 
-        for (StructureStart structurestart : this.structureMap.values())
+        while (objectiterator.hasNext())
         {
+            StructureStart structurestart = (StructureStart)objectiterator.next();
+
             if (structurestart.isSizeableStructure() && structurestart.isValidForPostProcess(chunkCoord) && structurestart.getBoundingBox().intersectsWith(i, j, i + 15, j + 15))
             {
                 structurestart.generateStructure(worldIn, randomIn, new StructureBoundingBox(i, j, i + 15, j + 15));
@@ -116,17 +117,33 @@
     @Nullable
     protected StructureStart getStructureAt(BlockPos pos)
     {
-        for (StructureStart structurestart : this.structureMap.values())
+        ObjectIterator objectiterator = this.structureMap.values().iterator();
+        label31:
+
+        while (objectiterator.hasNext())
         {
+            StructureStart structurestart = (StructureStart)objectiterator.next();
+
             if (structurestart.isSizeableStructure() && structurestart.getBoundingBox().isVecInside(pos))
             {
-                for (StructureComponent structurecomponent : structurestart.getComponents())
+                Iterator<StructureComponent> iterator = structurestart.getComponents().iterator();
+
+                while (true)
                 {
+                    if (!iterator.hasNext())
+                    {
+                        continue label31;
+                    }
+
+                    StructureComponent structurecomponent = iterator.next();
+
                     if (structurecomponent.getBoundingBox().isVecInside(pos))
                     {
-                        return structurestart;
+                        break;
                     }
                 }
+
+                return structurestart;
             }
         }
 
@@ -136,9 +153,12 @@
     public boolean isPositionInStructure(World worldIn, BlockPos pos)
     {
         this.initializeStructureData(worldIn);
+        ObjectIterator objectiterator = this.structureMap.values().iterator();
 
-        for (StructureStart structurestart : this.structureMap.values())
+        while (objectiterator.hasNext())
         {
+            StructureStart structurestart = (StructureStart)objectiterator.next();
+
             if (structurestart.isSizeableStructure() && structurestart.getBoundingBox().isVecInside(pos))
             {
                 return true;
@@ -155,12 +175,12 @@
     {
         if (this.structureData == null && worldIn != null)
         {
-            this.structureData = (MapGenStructureData)worldIn.loadData(MapGenStructureData.class, this.getStructureName());
+            this.structureData = (MapGenStructureData)worldIn.getPerWorldStorage().getOrLoadData(MapGenStructureData.class, this.getStructureName());
 
             if (this.structureData == null)
             {
                 this.structureData = new MapGenStructureData(this.getStructureName());
-                worldIn.setData(this.getStructureName(), this.structureData);
+                worldIn.getPerWorldStorage().setData(this.getStructureName(), this.structureData);
             }
             else
             {
@@ -201,29 +221,19 @@
 
     protected abstract StructureStart getStructureStart(int chunkX, int chunkZ);
 
-    protected static BlockPos findNearestStructurePosBySpacing(
-            World worldIn,
-            MapGenStructure structureType,
-            BlockPos startPos,
-            int distanceStep,
-            int stepOffset,
-            int randomSeedZ,
-            boolean addExtraRandomness,
-            int maxAttempts,
-            boolean findUnexplored
-        )
+    protected static BlockPos findNearestStructurePosBySpacing(World worldIn, MapGenStructure structureType, BlockPos startPos, int distanceStep, int stepOffset, int randomSeedZ, boolean addExtraRandomness, int maxAttempts, boolean findUnexplored)
     {
         int i = startPos.getX() >> 4;
         int j = startPos.getZ() >> 4;
         int k = 0;
 
-        for (Random random = new Random(); k <= maxAttempts; k++)
+        for (Random random = new Random(); k <= maxAttempts; ++k)
         {
-            for (int l = -k; l <= k; l++)
+            for (int l = -k; l <= k; ++l)
             {
                 boolean flag = l == -k || l == k;
 
-                for (int i1 = -k; i1 <= k; i1++)
+                for (int i1 = -k; i1 <= k; ++i1)
                 {
                     boolean flag1 = i1 == -k || i1 == k;
 
@@ -245,18 +255,18 @@
                         int l1 = j1 / distanceStep;
                         int i2 = k1 / distanceStep;
                         Random random1 = worldIn.setRandomSeed(l1, i2, randomSeedZ);
-                        l1 *= distanceStep;
-                        i2 *= distanceStep;
+                        l1 = l1 * distanceStep;
+                        i2 = i2 * distanceStep;
 
                         if (addExtraRandomness)
                         {
-                            l1 += (random1.nextInt(distanceStep - stepOffset) + random1.nextInt(distanceStep - stepOffset)) / 2;
-                            i2 += (random1.nextInt(distanceStep - stepOffset) + random1.nextInt(distanceStep - stepOffset)) / 2;
+                            l1 = l1 + (random1.nextInt(distanceStep - stepOffset) + random1.nextInt(distanceStep - stepOffset)) / 2;
+                            i2 = i2 + (random1.nextInt(distanceStep - stepOffset) + random1.nextInt(distanceStep - stepOffset)) / 2;
                         }
                         else
                         {
-                            l1 += random1.nextInt(distanceStep - stepOffset);
-                            i2 += random1.nextInt(distanceStep - stepOffset);
+                            l1 = l1 + random1.nextInt(distanceStep - stepOffset);
+                            i2 = i2 + random1.nextInt(distanceStep - stepOffset);
                         }
 
                         MapGenBase.setupChunkSeed(worldIn.getSeed(), random, l1, i2);
