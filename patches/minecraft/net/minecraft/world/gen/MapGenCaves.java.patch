--- before/net/minecraft/world/gen/MapGenCaves.java
+++ after/net/minecraft/world/gen/MapGenCaves.java
@@ -17,42 +17,12 @@
     protected static final IBlockState BLK_SANDSTONE = Blocks.SANDSTONE.getDefaultState();
     protected static final IBlockState BLK_RED_SANDSTONE = Blocks.RED_SANDSTONE.getDefaultState();
 
-    protected void addRoom(
-        long p_180703_1_, int p_180703_3_, int p_180703_4_, ChunkPrimer p_180703_5_, double p_180703_6_, double p_180703_8_, double p_180703_10_
-    )
+    protected void addRoom(long p_180703_1_, int p_180703_3_, int p_180703_4_, ChunkPrimer p_180703_5_, double p_180703_6_, double p_180703_8_, double p_180703_10_)
     {
-        this.addTunnel(
-            p_180703_1_,
-            p_180703_3_,
-            p_180703_4_,
-            p_180703_5_,
-            p_180703_6_,
-            p_180703_8_,
-            p_180703_10_,
-            1.0F + this.rand.nextFloat() * 6.0F,
-            0.0F,
-            0.0F,
-            -1,
-            -1,
-            0.5
-        );
+        this.addTunnel(p_180703_1_, p_180703_3_, p_180703_4_, p_180703_5_, p_180703_6_, p_180703_8_, p_180703_10_, 1.0F + this.rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
     }
 
-    protected void addTunnel(
-        long p_180702_1_,
-        int p_180702_3_,
-        int p_180702_4_,
-        ChunkPrimer p_180702_5_,
-        double p_180702_6_,
-        double p_180702_8_,
-        double p_180702_10_,
-        float p_180702_12_,
-        float p_180702_13_,
-        float p_180702_14_,
-        int p_180702_15_,
-        int p_180702_16_,
-        double p_180702_17_
-    )
+    protected void addTunnel(long p_180702_1_, int p_180702_3_, int p_180702_4_, ChunkPrimer p_180702_5_, double p_180702_6_, double p_180702_8_, double p_180702_10_, float p_180702_12_, float p_180702_13_, float p_180702_14_, int p_180702_15_, int p_180702_16_, double p_180702_17_)
     {
         double d0 = (double)(p_180702_3_ * 16 + 8);
         double d1 = (double)(p_180702_4_ * 16 + 8);
@@ -76,9 +46,9 @@
 
         int j = random.nextInt(p_180702_16_ / 2) + p_180702_16_ / 4;
 
-        for (boolean flag = random.nextInt(6) == 0; p_180702_15_ < p_180702_16_; p_180702_15_++)
+        for (boolean flag = random.nextInt(6) == 0; p_180702_15_ < p_180702_16_; ++p_180702_15_)
         {
-            double d2 = 1.5 + (double)(MathHelper.sin((float)p_180702_15_ * (float) Math.PI / (float)p_180702_16_) * p_180702_12_);
+            double d2 = 1.5D + (double)(MathHelper.sin((float)p_180702_15_ * (float)Math.PI / (float)p_180702_16_) * p_180702_12_);
             double d3 = d2 * p_180702_17_;
             float f2 = MathHelper.cos(p_180702_14_);
             float f3 = MathHelper.sin(p_180702_14_);
@@ -88,52 +58,24 @@
 
             if (flag)
             {
-                p_180702_14_ *= 0.92F;
+                p_180702_14_ = p_180702_14_ * 0.92F;
             }
             else
             {
-                p_180702_14_ *= 0.7F;
+                p_180702_14_ = p_180702_14_ * 0.7F;
             }
 
-            p_180702_14_ += f1 * 0.1F;
+            p_180702_14_ = p_180702_14_ + f1 * 0.1F;
             p_180702_13_ += f * 0.1F;
-            f1 *= 0.9F;
-            f *= 0.75F;
-            f1 += (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 2.0F;
-            f += (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 4.0F;
+            f1 = f1 * 0.9F;
+            f = f * 0.75F;
+            f1 = f1 + (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 2.0F;
+            f = f + (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 4.0F;
 
             if (!flag2 && p_180702_15_ == j && p_180702_12_ > 1.0F && p_180702_16_ > 0)
             {
-                this.addTunnel(
-                    random.nextLong(),
-                    p_180702_3_,
-                    p_180702_4_,
-                    p_180702_5_,
-                    p_180702_6_,
-                    p_180702_8_,
-                    p_180702_10_,
-                    random.nextFloat() * 0.5F + 0.5F,
-                    p_180702_13_ - (float)(Math.PI / 2),
-                    p_180702_14_ / 3.0F,
-                    p_180702_15_,
-                    p_180702_16_,
-                    1.0
-                );
-                this.addTunnel(
-                    random.nextLong(),
-                    p_180702_3_,
-                    p_180702_4_,
-                    p_180702_5_,
-                    p_180702_6_,
-                    p_180702_8_,
-                    p_180702_10_,
-                    random.nextFloat() * 0.5F + 0.5F,
-                    p_180702_13_ + (float)(Math.PI / 2),
-                    p_180702_14_ / 3.0F,
-                    p_180702_15_,
-                    p_180702_16_,
-                    1.0
-                );
+                this.addTunnel(random.nextLong(), p_180702_3_, p_180702_4_, p_180702_5_, p_180702_6_, p_180702_8_, p_180702_10_, random.nextFloat() * 0.5F + 0.5F, p_180702_13_ - ((float)Math.PI / 2F), p_180702_14_ / 3.0F, p_180702_15_, p_180702_16_, 1.0D);
+                this.addTunnel(random.nextLong(), p_180702_3_, p_180702_4_, p_180702_5_, p_180702_6_, p_180702_8_, p_180702_10_, random.nextFloat() * 0.5F + 0.5F, p_180702_13_ + ((float)Math.PI / 2F), p_180702_14_ / 3.0F, p_180702_15_, p_180702_16_, 1.0D);
                 return;
             }
 
@@ -149,10 +91,7 @@
                     return;
                 }
 
-                if (!(p_180702_6_ < d0 - 16.0 - d2 * 2.0)
-                        && !(p_180702_10_ < d1 - 16.0 - d2 * 2.0)
-                        && !(p_180702_6_ > d0 + 16.0 + d2 * 2.0)
-                        && !(p_180702_10_ > d1 + 16.0 + d2 * 2.0))
+                if (p_180702_6_ >= d0 - 16.0D - d2 * 2.0D && p_180702_10_ >= d1 - 16.0D - d2 * 2.0D && p_180702_6_ <= d0 + 16.0D + d2 * 2.0D && p_180702_10_ <= d1 + 16.0D + d2 * 2.0D)
                 {
                     int k2 = MathHelper.floor(p_180702_6_ - d2) - p_180702_3_ * 16 - 1;
                     int k = MathHelper.floor(p_180702_6_ + d2) - p_180702_3_ * 16 + 1;
@@ -193,17 +132,15 @@
 
                     boolean flag3 = false;
 
-                    for (int j1 = k2; !flag3 && j1 < k; j1++)
+                    for (int j1 = k2; !flag3 && j1 < k; ++j1)
                     {
-                        for (int k1 = i3; !flag3 && k1 < i1; k1++)
+                        for (int k1 = i3; !flag3 && k1 < i1; ++k1)
                         {
-                            for (int l1 = l + 1; !flag3 && l1 >= l2 - 1; l1--)
+                            for (int l1 = l + 1; !flag3 && l1 >= l2 - 1; --l1)
                             {
                                 if (l1 >= 0 && l1 < 256)
                                 {
-                                    IBlockState iblockstate = p_180702_5_.getBlockState(j1, l1, k1);
-
-                                    if (iblockstate.getBlock() == Blocks.FLOWING_WATER || iblockstate.getBlock() == Blocks.WATER)
+                                    if (isOceanBlock(p_180702_5_, j1, l1, k1, p_180702_3_, p_180702_4_))
                                     {
                                         flag3 = true;
                                     }
@@ -221,53 +158,32 @@
                     {
                         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
 
-                        for (int j3 = k2; j3 < k; j3++)
+                        for (int j3 = k2; j3 < k; ++j3)
                         {
-                            double d10 = ((double)(j3 + p_180702_3_ * 16) + 0.5 - p_180702_6_) / d2;
+                            double d10 = ((double)(j3 + p_180702_3_ * 16) + 0.5D - p_180702_6_) / d2;
 
-                            for (int i2 = i3; i2 < i1; i2++)
+                            for (int i2 = i3; i2 < i1; ++i2)
                             {
-                                double d8 = ((double)(i2 + p_180702_4_ * 16) + 0.5 - p_180702_10_) / d2;
+                                double d8 = ((double)(i2 + p_180702_4_ * 16) + 0.5D - p_180702_10_) / d2;
                                 boolean flag1 = false;
 
-                                if (d10 * d10 + d8 * d8 < 1.0)
+                                if (d10 * d10 + d8 * d8 < 1.0D)
                                 {
-                                    for (int j2 = l; j2 > l2; j2--)
+                                    for (int j2 = l; j2 > l2; --j2)
                                     {
-                                        double d9 = ((double)(j2 - 1) + 0.5 - p_180702_8_) / d3;
+                                        double d9 = ((double)(j2 - 1) + 0.5D - p_180702_8_) / d3;
 
-                                        if (d9 > -0.7 && d10 * d10 + d9 * d9 + d8 * d8 < 1.0)
+                                        if (d9 > -0.7D && d10 * d10 + d9 * d9 + d8 * d8 < 1.0D)
                                         {
                                             IBlockState iblockstate1 = p_180702_5_.getBlockState(j3, j2, i2);
-                                            IBlockState iblockstate2 = MoreObjects.firstNonNull(p_180702_5_.getBlockState(j3, j2 + 1, i2), BLK_AIR);
+                                            IBlockState iblockstate2 = (IBlockState)MoreObjects.firstNonNull(p_180702_5_.getBlockState(j3, j2 + 1, i2), BLK_AIR);
 
-                                            if (iblockstate1.getBlock() == Blocks.GRASS || iblockstate1.getBlock() == Blocks.MYCELIUM)
+                                            if (isTopBlock(p_180702_5_, j3, j2, i2, p_180702_3_, p_180702_4_))
                                             {
                                                 flag1 = true;
                                             }
 
-                                            if (this.canReplaceBlock(iblockstate1, iblockstate2))
-                                            {
-                                                if (j2 - 1 < 10)
-                                                {
-                                                    p_180702_5_.setBlockState(j3, j2, i2, BLK_LAVA);
-                                                }
-                                                else
-                                                {
-                                                    p_180702_5_.setBlockState(j3, j2, i2, BLK_AIR);
-
-                                                    if (flag1 && p_180702_5_.getBlockState(j3, j2 - 1, i2).getBlock() == Blocks.DIRT)
-                                                    {
-                                                        blockpos$mutableblockpos.setPos(j3 + p_180702_3_ * 16, 0, i2 + p_180702_4_ * 16);
-                                                        p_180702_5_.setBlockState(
-                                                            j3,
-                                                            j2 - 1,
-                                                            i2,
-                                                            this.world.getBiome(blockpos$mutableblockpos).topBlock.getBlock().getDefaultState()
-                                                        );
-                                                    }
-                                                }
-                                            }
+                                            digBlock(p_180702_5_, j3, j2, i2, p_180702_3_, p_180702_4_, flag1, iblockstate1, iblockstate2);
                                         }
                                     }
                                 }
@@ -318,16 +234,16 @@
         {
             return true;
         }
+        else if (p_175793_1_.getBlock() == Blocks.SNOW_LAYER)
+        {
+            return true;
+        }
         else
         {
-            return p_175793_1_.getBlock() == Blocks.SNOW_LAYER
-                   ? true
-                   : (p_175793_1_.getBlock() == Blocks.SAND || p_175793_1_.getBlock() == Blocks.GRAVEL)
-                   && p_175793_2_.getMaterial() != Material.WATER;
+            return (p_175793_1_.getBlock() == Blocks.SAND || p_175793_1_.getBlock() == Blocks.GRAVEL) && p_175793_2_.getMaterial() != Material.WATER;
         }
     }
 
-    @Override
     protected void recursiveGenerate(World worldIn, int chunkX, int chunkZ, int originalX, int originalZ, ChunkPrimer chunkPrimerIn)
     {
         int i = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(15) + 1) + 1);
@@ -337,7 +253,7 @@
             i = 0;
         }
 
-        for (int j = 0; j < i; j++)
+        for (int j = 0; j < i; ++j)
         {
             double d0 = (double)(chunkX * 16 + this.rand.nextInt(16));
             double d1 = (double)this.rand.nextInt(this.rand.nextInt(120) + 8);
@@ -350,9 +266,9 @@
                 k += this.rand.nextInt(4);
             }
 
-            for (int l = 0; l < k; l++)
+            for (int l = 0; l < k; ++l)
             {
-                float f = this.rand.nextFloat() * (float)(Math.PI * 2);
+                float f = this.rand.nextFloat() * ((float)Math.PI * 2F);
                 float f1 = (this.rand.nextFloat() - 0.5F) * 2.0F / 8.0F;
                 float f2 = this.rand.nextFloat() * 2.0F + this.rand.nextFloat();
 
@@ -361,7 +277,69 @@
                     f2 *= this.rand.nextFloat() * this.rand.nextFloat() * 3.0F + 1.0F;
                 }
 
-                this.addTunnel(this.rand.nextLong(), originalX, originalZ, chunkPrimerIn, d0, d1, d2, f2, f, f1, 0, 0, 1.0);
+                this.addTunnel(this.rand.nextLong(), originalX, originalZ, chunkPrimerIn, d0, d1, d2, f2, f, f1, 0, 0, 1.0D);
+            }
+        }
+    }
+
+    protected boolean isOceanBlock(ChunkPrimer data, int x, int y, int z, int chunkX, int chunkZ)
+    {
+        net.minecraft.block.Block block = data.getBlockState(x, y, z).getBlock();
+        return block== Blocks.FLOWING_WATER || block == Blocks.WATER;
+    }
+
+    //Exception biomes to make sure we generate like vanilla
+    private boolean isExceptionBiome(net.minecraft.world.biome.Biome biome)
+    {
+        if (biome == net.minecraft.init.Biomes.BEACH) return true;
+        if (biome == net.minecraft.init.Biomes.DESERT) return true;
+        return false;
+    }
+
+    //Determine if the block at the specified location is the top block for the biome, we take into account
+    //Vanilla bugs to make sure that we generate the map the same way vanilla does.
+    private boolean isTopBlock(ChunkPrimer data, int x, int y, int z, int chunkX, int chunkZ)
+    {
+        net.minecraft.world.biome.Biome biome = world.getBiome(new BlockPos(x + chunkX * 16, 0, z + chunkZ * 16));
+        IBlockState state = data.getBlockState(x, y, z);
+        return (isExceptionBiome(biome) ? state.getBlock() == Blocks.GRASS : state.getBlock() == biome.topBlock);
+    }
+
+    /**
+     * Digs out the current block, default implementation removes stone, filler, and top block
+     * Sets the block to lava if y is less then 10, and air other wise.
+     * If setting to air, it also checks to see if we've broken the surface and if so
+     * tries to make the floor the biome's top block
+     *
+     * @param data Block data array
+     * @param index Pre-calculated index into block data
+     * @param x local X position
+     * @param y local Y position
+     * @param z local Z position
+     * @param chunkX Chunk X position
+     * @param chunkZ Chunk Y position
+     * @param foundTop True if we've encountered the biome's top block. Ideally if we've broken the surface.
+     */
+    protected void digBlock(ChunkPrimer data, int x, int y, int z, int chunkX, int chunkZ, boolean foundTop, IBlockState state, IBlockState up)
+    {
+        net.minecraft.world.biome.Biome biome = world.getBiome(new BlockPos(x + chunkX * 16, 0, z + chunkZ * 16));
+        IBlockState top = biome.topBlock;
+        IBlockState filler = biome.fillerBlock;
+
+        if (this.canReplaceBlock(state, up) || state.getBlock() == top.getBlock() || state.getBlock() == filler.getBlock())
+        {
+            if (y - 1 < 10)
+            {
+                data.setBlockState(x, y, z, BLK_LAVA);
+            }
+            else
+            {
+                data.setBlockState(x, y, z, BLK_AIR);
+
+                if (foundTop && data.getBlockState(x, y - 1, z).getBlock() == filler.getBlock())
+                {
+                    data.setBlockState(x, y - 1, z, top.getBlock().getDefaultState());
+                }
             }
         }
     }
