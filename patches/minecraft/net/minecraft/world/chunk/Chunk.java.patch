--- before/net/minecraft/world/chunk/Chunk.java
+++ after/net/minecraft/world/chunk/Chunk.java
@@ -41,21 +41,21 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-public class Chunk
+public class Chunk implements net.minecraftforge.common.capabilities.ICapabilityProvider
 {
     private static final Logger LOGGER = LogManager.getLogger();
     public static final ExtendedBlockStorage NULL_BLOCK_STORAGE = null;
-    private final ExtendedBlockStorage[] storageArrays = new ExtendedBlockStorage[16];
-    private final byte[] blockBiomeArray = new byte[256];
-    private final int[] precipitationHeightMap = new int[256];
-    private final boolean[] updateSkylightColumns = new boolean[256];
+    private final ExtendedBlockStorage[] storageArrays;
+    private final byte[] blockBiomeArray;
+    private final int[] precipitationHeightMap;
+    private final boolean[] updateSkylightColumns;
     private boolean loaded;
     private final World world;
     private final int[] heightMap;
     public final int x;
     public final int z;
     private boolean isGapLightingUpdated;
-    private final Map<BlockPos, TileEntity> tileEntities = Maps.newHashMap();
+    private final Map<BlockPos, TileEntity> tileEntities;
     private final ClassInheritanceMultiMap<Entity>[] entityLists;
     private boolean isTerrainPopulated;
     private boolean isLightPopulated;
@@ -65,25 +65,33 @@
     private long lastSaveTime;
     private int heightMapMinimum;
     private long inhabitedTime;
-    private int queuedLightChecks = 4096;
-    private final ConcurrentLinkedQueue<BlockPos> tileEntityPosQueue = Queues.newConcurrentLinkedQueue();
+    private int queuedLightChecks;
+    private final ConcurrentLinkedQueue<BlockPos> tileEntityPosQueue;
     public boolean unloadQueued;
 
     public Chunk(World worldIn, int x, int z)
     {
-        this.entityLists = new ClassInheritanceMultiMap[16];
+        this.storageArrays = new ExtendedBlockStorage[16];
+        this.blockBiomeArray = new byte[256];
+        this.precipitationHeightMap = new int[256];
+        this.updateSkylightColumns = new boolean[256];
+        this.tileEntities = Maps.<BlockPos, TileEntity>newHashMap();
+        this.queuedLightChecks = 4096;
+        this.tileEntityPosQueue = Queues.<BlockPos>newConcurrentLinkedQueue();
+        this.entityLists = (ClassInheritanceMultiMap[])(new ClassInheritanceMultiMap[16]);
         this.world = worldIn;
         this.x = x;
         this.z = z;
         this.heightMap = new int[256];
 
-        for (int i = 0; i < this.entityLists.length; i++)
+        for (int i = 0; i < this.entityLists.length; ++i)
         {
-            this.entityLists[i] = new ClassInheritanceMultiMap<>(Entity.class);
+            this.entityLists[i] = new ClassInheritanceMultiMap(Entity.class);
         }
 
         Arrays.fill(this.precipitationHeightMap, -999);
         Arrays.fill(this.blockBiomeArray, (byte) - 1);
+        capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this);
     }
 
     public Chunk(World worldIn, ChunkPrimer primer, int x, int z)
@@ -92,11 +100,11 @@
         int i = 256;
         boolean flag = worldIn.provider.hasSkyLight();
 
-        for (int j = 0; j < 16; j++)
+        for (int j = 0; j < 16; ++j)
         {
-            for (int k = 0; k < 16; k++)
+            for (int k = 0; k < 16; ++k)
             {
-                for (int l = 0; l < 256; l++)
+                for (int l = 0; l < 256; ++l)
                 {
                     IBlockState iblockstate = primer.getBlockState(j, l, k);
 
@@ -134,7 +142,7 @@
     @Nullable
     private ExtendedBlockStorage getLastExtendedBlockStorage()
     {
-        for (int i = this.storageArrays.length - 1; i >= 0; i--)
+        for (int i = this.storageArrays.length - 1; i >= 0; --i)
         {
             if (this.storageArrays[i] != NULL_BLOCK_STORAGE)
             {
@@ -162,17 +170,17 @@
         int i = this.getTopFilledSegment();
         this.heightMapMinimum = Integer.MAX_VALUE;
 
-        for (int j = 0; j < 16; j++)
+        for (int j = 0; j < 16; ++j)
         {
-            for (int k = 0; k < 16; k++)
+            for (int k = 0; k < 16; ++k)
             {
                 this.precipitationHeightMap[j + (k << 4)] = -999;
 
-                for (int l = i + 16; l > 0; l--)
+                for (int l = i + 16; l > 0; --l)
                 {
                     IBlockState iblockstate = this.getBlockState(j, l - 1, k);
 
-                    if (iblockstate.getLightOpacity() != 0)
+                    if (this.getBlockLightOpacity(j, l - 1, k) != 0)
                     {
                         this.heightMap[k << 4 | j] = l;
 
@@ -195,13 +203,13 @@
         int i = this.getTopFilledSegment();
         this.heightMapMinimum = Integer.MAX_VALUE;
 
-        for (int j = 0; j < 16; j++)
+        for (int j = 0; j < 16; ++j)
         {
-            for (int k = 0; k < 16; k++)
+            for (int k = 0; k < 16; ++k)
             {
                 this.precipitationHeightMap[j + (k << 4)] = -999;
 
-                for (int l = i + 16; l > 0; l--)
+                for (int l = i + 16; l > 0; --l)
                 {
                     if (this.getBlockLightOpacity(j, l - 1, k) != 0)
                     {
@@ -243,7 +251,9 @@
                             }
                         }
 
-                        if (--i1 <= 0 || k1 <= 0)
+                        --i1;
+
+                        if (i1 <= 0 || k1 <= 0)
                         {
                             break;
                         }
@@ -267,9 +277,9 @@
 
         if (this.world.isAreaLoaded(new BlockPos(this.x * 16 + 8, 0, this.z * 16 + 8), 16))
         {
-            for (int i = 0; i < 16; i++)
+            for (int i = 0; i < 16; ++i)
             {
-                for (int j = 0; j < 16; j++)
+                for (int j = 0; j < 16; ++j)
                 {
                     if (this.updateSkylightColumns[i + j * 16])
                     {
@@ -324,7 +334,7 @@
     {
         if (endY > startY && this.world.isAreaLoaded(new BlockPos(x, 0, z), 16))
         {
-            for (int i = startY; i < endY; i++)
+            for (int i = startY; i < endY; ++i)
             {
                 this.world.checkLightFor(EnumSkyBlock.SKY, new BlockPos(x, i, z));
             }
@@ -335,7 +345,7 @@
 
     private void relightBlock(int x, int y, int z)
     {
-        int i = this.heightMap[z << 4 | x] & 0xFF;
+        int i = this.heightMap[z << 4 | x] & 255;
         int j = i;
 
         if (y > i)
@@ -345,7 +355,7 @@
 
         while (j > 0 && this.getBlockLightOpacity(x, j - 1, z) == 0)
         {
-            j--;
+            --j;
         }
 
         if (j != i)
@@ -359,7 +369,7 @@
             {
                 if (j < i)
                 {
-                    for (int j1 = j; j1 < i; j1++)
+                    for (int j1 = j; j1 < i; ++j1)
                     {
                         ExtendedBlockStorage extendedblockstorage2 = this.storageArrays[j1 >> 4];
 
@@ -372,7 +382,7 @@
                 }
                 else
                 {
-                    for (int i1 = i; i1 < j; i1++)
+                    for (int i1 = i; i1 < j; ++i1)
                     {
                         ExtendedBlockStorage extendedblockstorage = this.storageArrays[i1 >> 4];
 
@@ -388,7 +398,8 @@
 
                 while (j > 0 && k1 > 0)
                 {
-                    int i2 = this.getBlockLightOpacity(x, --j, z);
+                    --j;
+                    int i2 = this.getBlockLightOpacity(x, j, z);
 
                     if (i2 == 0)
                     {
@@ -442,12 +453,13 @@
 
     public int getBlockLightOpacity(BlockPos pos)
     {
-        return this.getBlockState(pos).getLightOpacity();
+        return this.getBlockState(pos).getLightOpacity(this.world, pos);
     }
 
     private int getBlockLightOpacity(int x, int y, int z)
     {
-        return this.getBlockState(x, y, z).getLightOpacity();
+        IBlockState state = this.getBlockState(x, y, z); //Forge: Can sometimes be called before we are added to the global world list. So use the less accurate one during that. It'll be recalculated later
+        return !loaded ? state.getLightOpacity() : state.getLightOpacity(world, new BlockPos(this.x << 4 | x & 15, y, this.z << 4 | z & 15));
     }
 
     public IBlockState getBlockState(BlockPos pos)
@@ -529,6 +541,7 @@
         {
             Block block = state.getBlock();
             Block block1 = iblockstate.getBlock();
+            int k1 = iblockstate.getLightOpacity(this.world, pos); // Relocate old light value lookup here, so that it is called before TE is removed.
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
             boolean flag = false;
 
@@ -546,14 +559,19 @@
 
             extendedblockstorage.set(i, j & 15, k, state);
 
-            if (block1 != block)
+            //if (block1 != block)
             {
                 if (!this.world.isRemote)
                 {
+                    if (block1 != block) //Only fire block breaks when the block changes.
                     block1.breakBlock(this.world, pos, iblockstate);
+                    TileEntity te = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
+                    if (te != null && te.shouldRefresh(this.world, pos, iblockstate, state)) this.world.removeTileEntity(pos);
                 }
-                else if (block1 instanceof ITileEntityProvider)
+                else if (block1.hasTileEntity(iblockstate))
                 {
+                    TileEntity te = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
+                    if (te != null && te.shouldRefresh(this.world, pos, iblockstate, state))
                     this.world.removeTileEntity(pos);
                 }
             }
@@ -570,8 +588,7 @@
                 }
                 else
                 {
-                    int j1 = state.getLightOpacity();
-                    int k1 = iblockstate.getLightOpacity();
+                    int j1 = state.getLightOpacity(this.world, pos);
 
                     if (j1 > 0)
                     {
@@ -591,28 +608,19 @@
                     }
                 }
 
-                if (block1 instanceof ITileEntityProvider)
-                {
-                    TileEntity tileentity = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
-
-                    if (tileentity != null)
-                    {
-                        tileentity.updateContainingBlockInfo();
-                    }
-                }
-
-                if (!this.world.isRemote && block1 != block)
+                // If capturing blocks, only run block physics for TE's. Non-TE's are handled in ForgeHooks.onPlaceItemIntoWorld
+                if (!this.world.isRemote && block1 != block && (!this.world.captureBlockSnapshots || block.hasTileEntity(state)))
                 {
                     block.onBlockAdded(this.world, pos, state);
                 }
 
-                if (block instanceof ITileEntityProvider)
+                if (block.hasTileEntity(state))
                 {
                     TileEntity tileentity1 = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
 
                     if (tileentity1 == null)
                     {
-                        tileentity1 = ((ITileEntityProvider)block).createNewTileEntity(this.world, block.getMetaFromState(state));
+                        tileentity1 = block.createTileEntity(this.world, state);
                         this.world.setTileEntity(pos, tileentity1);
                     }
 
@@ -687,14 +695,12 @@
 
         if (extendedblockstorage == NULL_BLOCK_STORAGE)
         {
-            return this.world.provider.hasSkyLight() && amount < EnumSkyBlock.SKY.defaultLightValue
-                   ? EnumSkyBlock.SKY.defaultLightValue - amount
-                   : 0;
+            return this.world.provider.hasSkyLight() && amount < EnumSkyBlock.SKY.defaultLightValue ? EnumSkyBlock.SKY.defaultLightValue - amount : 0;
         }
         else
         {
             int l = !this.world.provider.hasSkyLight() ? 0 : extendedblockstorage.getSkyLight(i, j & 15, k);
-            l -= amount;
+            l = l - amount;
             int i1 = extendedblockstorage.getBlockLight(i, j & 15, k);
 
             if (i1 > l)
@@ -709,16 +715,16 @@
     public void addEntity(Entity entityIn)
     {
         this.hasEntities = true;
-        int i = MathHelper.floor(entityIn.posX / 16.0);
-        int j = MathHelper.floor(entityIn.posZ / 16.0);
+        int i = MathHelper.floor(entityIn.posX / 16.0D);
+        int j = MathHelper.floor(entityIn.posZ / 16.0D);
 
         if (i != this.x || j != this.z)
         {
-            LOGGER.warn("Wrong location! ({}, {}) should be ({}, {}), {}", i, j, this.x, this.z, entityIn);
+            LOGGER.warn("Wrong location! ({}, {}) should be ({}, {}), {}", Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(this.x), Integer.valueOf(this.z), entityIn);
             entityIn.setDead();
         }
 
-        int k = MathHelper.floor(entityIn.posY / 16.0);
+        int k = MathHelper.floor(entityIn.posY / 16.0D);
 
         if (k < 0)
         {
@@ -730,11 +736,13 @@
             k = this.entityLists.length - 1;
         }
 
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityEvent.EnteringChunk(entityIn, this.x, this.z, entityIn.chunkCoordX, entityIn.chunkCoordZ));
         entityIn.addedToChunk = true;
         entityIn.chunkCoordX = this.x;
         entityIn.chunkCoordY = k;
         entityIn.chunkCoordZ = this.z;
         this.entityLists[k].add(entityIn);
+        this.markDirty(); // Forge - ensure chunks are marked to save after an entity add
     }
 
     public void removeEntity(Entity entityIn)
@@ -755,6 +763,7 @@
         }
 
         this.entityLists[index].remove(entityIn);
+        this.markDirty(); // Forge - ensure chunks are marked to save after entity removals
     }
 
     public boolean canSeeSky(BlockPos pos)
@@ -770,9 +779,7 @@
     {
         IBlockState iblockstate = this.getBlockState(pos);
         Block block = iblockstate.getBlock();
-        return !block.hasTileEntity()
-               ? null
-               : ((ITileEntityProvider)block).createNewTileEntity(this.world, iblockstate.getBlock().getMetaFromState(iblockstate));
+        return !block.hasTileEntity(iblockstate) ? null : block.createTileEntity(this.world, iblockstate);
     }
 
     @Nullable
@@ -780,6 +787,12 @@
     {
         TileEntity tileentity = this.tileEntities.get(pos);
 
+        if (tileentity != null && tileentity.isInvalid())
+        {
+            tileEntities.remove(pos);
+            tileentity = null;
+        }
+
         if (tileentity == null)
         {
             if (creationMode == Chunk.EnumCreateEntityType.IMMEDIATE)
@@ -789,13 +802,8 @@
             }
             else if (creationMode == Chunk.EnumCreateEntityType.QUEUED)
             {
-                this.tileEntityPosQueue.add(pos);
+                this.tileEntityPosQueue.add(pos.toImmutable());
             }
-        }
-        else if (tileentity.isInvalid())
-        {
-            this.tileEntities.remove(pos);
-            return null;
         }
 
         return tileentity;
@@ -813,14 +821,15 @@
 
     public void addTileEntity(BlockPos pos, TileEntity tileEntityIn)
     {
+        if (tileEntityIn.getWorld() != this.world) //Forge don't call unless it's changed, could screw up bad mods.
         tileEntityIn.setWorld(this.world);
         tileEntityIn.setPos(pos);
 
-        if (this.getBlockState(pos).getBlock() instanceof ITileEntityProvider)
+        if (this.getBlockState(pos).getBlock().hasTileEntity(this.getBlockState(pos)))
         {
             if (this.tileEntities.containsKey(pos))
             {
-                this.tileEntities.get(pos).invalidate();
+                ((TileEntity)this.tileEntities.get(pos)).invalidate();
             }
 
             tileEntityIn.validate();
@@ -848,12 +857,14 @@
 
         for (ClassInheritanceMultiMap<Entity> classinheritancemultimap : this.entityLists)
         {
-            this.world.loadEntities(classinheritancemultimap);
+            this.world.loadEntities(com.google.common.collect.ImmutableList.copyOf(classinheritancemultimap));
         }
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Load(this));
     }
 
     public void onUnload()
     {
+        java.util.Arrays.stream(entityLists).forEach(multimap -> com.google.common.collect.Lists.newArrayList(multimap.getByClass(net.minecraft.entity.player.EntityPlayer.class)).forEach(player -> world.updateEntityWithOptionalForce(player, false))); // FORGE - Fix for MC-92916
         this.loaded = false;
 
         for (TileEntity tileentity : this.tileEntities.values())
@@ -865,6 +876,7 @@
         {
             this.world.unloadEntities(classinheritancemultimap);
         }
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Unload(this));
     }
 
     public void markDirty()
@@ -874,12 +886,12 @@
 
     public void getEntitiesWithinAABBForEntity(@Nullable Entity entityIn, AxisAlignedBB aabb, List<Entity> listToFill, Predicate <? super Entity > filter)
     {
-        int i = MathHelper.floor((aabb.minY - 2.0) / 16.0);
-        int j = MathHelper.floor((aabb.maxY + 2.0) / 16.0);
+        int i = MathHelper.floor((aabb.minY - World.MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.floor((aabb.maxY + World.MAX_ENTITY_RADIUS) / 16.0D);
         i = MathHelper.clamp(i, 0, this.entityLists.length - 1);
         j = MathHelper.clamp(j, 0, this.entityLists.length - 1);
 
-        for (int k = i; k <= j; k++)
+        for (int k = i; k <= j; ++k)
         {
             if (!this.entityLists[k].isEmpty())
             {
@@ -898,8 +910,7 @@
                         {
                             for (Entity entity1 : aentity)
                             {
-                                if (entity1 != entityIn && entity1.getEntityBoundingBox().intersects(aabb) && (filter == null || filter.apply(entity1))
-                                   )
+                                if (entity1 != entityIn && entity1.getEntityBoundingBox().intersects(aabb) && (filter == null || filter.apply(entity1)))
                                 {
                                     listToFill.add(entity1);
                                 }
@@ -911,16 +922,14 @@
         }
     }
 
-    public <T extends Entity> void getEntitiesOfTypeWithinAABB(
-        Class <? extends T > entityClass, AxisAlignedBB aabb, List<T> listToFill, Predicate <? super T > filter
-    )
+    public <T extends Entity> void getEntitiesOfTypeWithinAABB(Class <? extends T > entityClass, AxisAlignedBB aabb, List<T> listToFill, Predicate <? super T > filter)
     {
-        int i = MathHelper.floor((aabb.minY - 2.0) / 16.0);
-        int j = MathHelper.floor((aabb.maxY + 2.0) / 16.0);
+        int i = MathHelper.floor((aabb.minY - World.MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.floor((aabb.maxY + World.MAX_ENTITY_RADIUS) / 16.0D);
         i = MathHelper.clamp(i, 0, this.entityLists.length - 1);
         j = MathHelper.clamp(j, 0, this.entityLists.length - 1);
 
-        for (int k = i; k <= j; k++)
+        for (int k = i; k <= j; ++k)
         {
             for (T t : this.entityLists[k].getByClass(entityClass))
             {
@@ -951,14 +960,7 @@
 
     public Random getRandomWithSeed(long seed)
     {
-        return new Random(
-                   this.world.getSeed()
-                   + this.x * this.x * 4987142
-                   + this.x * 5947611
-                   + this.z * this.z * 4392871L
-                   + this.z * 389711
-                   ^ seed
-               );
+        return new Random(this.world.getSeed() + (long)(this.x * this.x * 4987142) + (long)(this.x * 5947611) + (long)(this.z * this.z) * 4392871L + (long)(this.z * 389711) ^ seed);
     }
 
     public boolean isEmpty()
@@ -1001,6 +1003,9 @@
 
     protected void populate(IChunkGenerator generator)
     {
+        if (populating != null && net.minecraftforge.common.ForgeModContainer.logCascadingWorldGeneration) logCascadingWorldGeneration();
+        ChunkPos prev = populating;
+        populating = this.getPos();
         if (this.isTerrainPopulated())
         {
             if (generator.generateStructures(this, this.x, this.z))
@@ -1012,8 +1017,10 @@
         {
             this.checkLight();
             generator.populate(this.x, this.z);
+            net.minecraftforge.fml.common.registry.GameRegistry.generateWorld(this.x, this.z, this.world, generator, this.world.getChunkProvider());
             this.markDirty();
         }
+        populating = prev;
     }
 
     public BlockPos getPrecipitationHeight(BlockPos pos)
@@ -1068,7 +1075,7 @@
         {
             BlockPos blockpos = this.tileEntityPosQueue.poll();
 
-            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlockState(blockpos).getBlock().hasTileEntity())
+            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlockState(blockpos).getBlock().hasTileEntity(this.getBlockState(blockpos)))
             {
                 TileEntity tileentity = this.createNewTileEntity(blockpos);
                 this.world.setTileEntity(blockpos, tileentity);
@@ -1121,7 +1128,7 @@
     {
         if (this.storageArrays.length != newStorageArrays.length)
         {
-            LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", newStorageArrays.length, this.storageArrays.length);
+            LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", Integer.valueOf(newStorageArrays.length), Integer.valueOf(this.storageArrays.length));
         }
         else
         {
@@ -1132,9 +1139,16 @@
     @SideOnly(Side.CLIENT)
     public void read(PacketBuffer buf, int availableSections, boolean groundUpContinuous)
     {
+        for(TileEntity tileEntity : tileEntities.values())
+        {
+            tileEntity.updateContainingBlockInfo();
+            tileEntity.getBlockMetadata();
+            tileEntity.getBlockType();
+        }
+
         boolean flag = this.world.provider.hasSkyLight();
 
-        for (int i = 0; i < this.storageArrays.length; i++)
+        for (int i = 0; i < this.storageArrays.length; ++i)
         {
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[i];
 
@@ -1168,7 +1182,7 @@
             buf.readBytes(this.blockBiomeArray);
         }
 
-        for (int j = 0; j < this.storageArrays.length; j++)
+        for (int j = 0; j < this.storageArrays.length; ++j)
         {
             if (this.storageArrays[j] != NULL_BLOCK_STORAGE && (availableSections & 1 << j) != 0)
             {
@@ -1180,10 +1194,16 @@
         this.isTerrainPopulated = true;
         this.generateHeightMap();
 
+        List<TileEntity> invalidList = new java.util.ArrayList<TileEntity>();
+
         for (TileEntity tileentity : this.tileEntities.values())
         {
+            if (tileentity.shouldRefresh(this.world, tileentity.getPos(), tileentity.getBlockType().getStateFromMeta(tileentity.getBlockMetadata()), getBlockState(tileentity.getPos())))
+                invalidList.add(tileentity);
             tileentity.updateContainingBlockInfo();
         }
+
+        for (TileEntity te : invalidList) te.invalidate();
     }
 
     public Biome getBiome(BlockPos pos, BiomeProvider provider)
@@ -1194,9 +1214,14 @@
 
         if (k == 255)
         {
-            Biome biome = provider.getBiome(pos, Biomes.PLAINS);
+            // Forge: checking for client ensures that biomes are only generated on integrated server
+            // in singleplayer. Generating biomes on the client may corrupt the biome ID arrays on
+            // the server while they are being generated because IntCache can't be thread safe,
+            // so client and server may end up filling the same array.
+            // This is not necessary in 1.13 and newer versions.
+            Biome biome = world.isRemote ? Biomes.PLAINS : provider.getBiome(pos, Biomes.PLAINS);
             k = Biome.getIdForBiome(biome);
-            this.blockBiomeArray[j << 4 | i] = (byte)(k & 0xFF);
+            this.blockBiomeArray[j << 4 | i] = (byte)(k & 255);
         }
 
         Biome biome1 = Biome.getBiome(k);
@@ -1212,7 +1237,7 @@
     {
         if (this.blockBiomeArray.length != biomeArray.length)
         {
-            LOGGER.warn("Could not set level chunk biomes, array length is {} instead of {}", biomeArray.length, this.blockBiomeArray.length);
+            LOGGER.warn("Could not set level chunk biomes, array length is {} instead of {}", Integer.valueOf(biomeArray.length), Integer.valueOf(this.blockBiomeArray.length));
         }
         else
         {
@@ -1231,7 +1256,7 @@
         {
             BlockPos blockpos = new BlockPos(this.x << 4, 0, this.z << 4);
 
-            for (int i = 0; i < 8; i++)
+            for (int i = 0; i < 8; ++i)
             {
                 if (this.queuedLightChecks >= 4096)
                 {
@@ -1241,21 +1266,20 @@
                 int j = this.queuedLightChecks % 16;
                 int k = this.queuedLightChecks / 16 % 16;
                 int l = this.queuedLightChecks / 256;
-                this.queuedLightChecks++;
+                ++this.queuedLightChecks;
 
-                for (int i1 = 0; i1 < 16; i1++)
+                for (int i1 = 0; i1 < 16; ++i1)
                 {
                     BlockPos blockpos1 = blockpos.add(k, (j << 4) + i1, l);
                     boolean flag = i1 == 0 || i1 == 15 || k == 0 || k == 15 || l == 0 || l == 15;
 
-                    if (this.storageArrays[j] == NULL_BLOCK_STORAGE && flag
-                            || this.storageArrays[j] != NULL_BLOCK_STORAGE && this.storageArrays[j].get(k, i1, l).getMaterial() == Material.AIR)
+                    if (this.storageArrays[j] == NULL_BLOCK_STORAGE && flag || this.storageArrays[j] != NULL_BLOCK_STORAGE && this.storageArrays[j].get(k, i1, l).getBlock().isAir(this.storageArrays[j].get(k, i1, l), this.world, blockpos1))
                     {
                         for (EnumFacing enumfacing : EnumFacing.values())
                         {
                             BlockPos blockpos2 = blockpos1.offset(enumfacing);
 
-                            if (this.world.getBlockState(blockpos2).getLightValue() > 0)
+                            if (this.world.getBlockState(blockpos2).getLightValue(this.world, blockpos2) > 0)
                             {
                                 this.world.checkLight(blockpos2);
                             }
@@ -1280,9 +1304,9 @@
             {
                 label44:
 
-                for (int i = 0; i < 16; i++)
+                for (int i = 0; i < 16; ++i)
                 {
-                    for (int j = 0; j < 16; j++)
+                    for (int j = 0; j < 16; ++j)
                     {
                         if (!this.checkLight(i, j))
                         {
@@ -1312,7 +1336,7 @@
 
     private void setSkylightUpdated()
     {
-        for (int i = 0; i < this.updateSkylightColumns.length; i++)
+        for (int i = 0; i < this.updateSkylightColumns.length; ++i)
         {
             this.updateSkylightColumns[i] = true;
         }
@@ -1326,28 +1350,28 @@
         {
             if (facing == EnumFacing.EAST)
             {
-                for (int i = 0; i < 16; i++)
+                for (int i = 0; i < 16; ++i)
                 {
                     this.checkLight(15, i);
                 }
             }
             else if (facing == EnumFacing.WEST)
             {
-                for (int j = 0; j < 16; j++)
+                for (int j = 0; j < 16; ++j)
                 {
                     this.checkLight(0, j);
                 }
             }
             else if (facing == EnumFacing.SOUTH)
             {
-                for (int k = 0; k < 16; k++)
+                for (int k = 0; k < 16; ++k)
                 {
                     this.checkLight(k, 15);
                 }
             }
             else if (facing == EnumFacing.NORTH)
             {
-                for (int l = 0; l < 16; l++)
+                for (int l = 0; l < 16; ++l)
                 {
                     this.checkLight(l, 0);
                 }
@@ -1360,11 +1384,9 @@
         int i = this.getTopFilledSegment();
         boolean flag = false;
         boolean flag1 = false;
-        BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos(
-            (this.x << 4) + x, 0, (this.z << 4) + z
-        );
+        BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos((this.x << 4) + x, 0, (this.z << 4) + z);
 
-        for (int j = i + 16 - 1; j > this.world.getSeaLevel() || j > 0 && !flag1; j--)
+        for (int j = i + 16 - 1; j > this.world.getSeaLevel() || j > 0 && !flag1; --j)
         {
             blockpos$mutableblockpos.setPos(blockpos$mutableblockpos.getX(), j, blockpos$mutableblockpos.getZ());
             int k = this.getBlockLightOpacity(blockpos$mutableblockpos);
@@ -1384,11 +1406,11 @@
             }
         }
 
-        for (int l = blockpos$mutableblockpos.getY(); l > 0; l--)
+        for (int l = blockpos$mutableblockpos.getY(); l > 0; --l)
         {
             blockpos$mutableblockpos.setPos(blockpos$mutableblockpos.getX(), l, blockpos$mutableblockpos.getZ());
 
-            if (this.getBlockState(blockpos$mutableblockpos).getLightValue() > 0)
+            if (this.getBlockState(blockpos$mutableblockpos).getLightValue(this.world, blockpos$mutableblockpos) > 0)
             {
                 this.world.checkLight(blockpos$mutableblockpos);
             }
@@ -1422,11 +1444,12 @@
     {
         if (this.heightMap.length != newHeightMap.length)
         {
-            LOGGER.warn("Could not set level chunk heightmap, array length is {} instead of {}", newHeightMap.length, this.heightMap.length);
+            LOGGER.warn("Could not set level chunk heightmap, array length is {} instead of {}", Integer.valueOf(newHeightMap.length), Integer.valueOf(this.heightMap.length));
         }
         else
         {
             System.arraycopy(newHeightMap, 0, this.heightMap, 0, this.heightMap.length);
+            this.heightMapMinimum = com.google.common.primitives.Ints.min(this.heightMap); // Forge: fix MC-117412
         }
     }
 
@@ -1495,5 +1518,56 @@
         IMMEDIATE,
         QUEUED,
         CHECK;
+    }
+
+    /* ======================================== FORGE START =====================================*/
+    /**
+     * Removes the tile entity at the specified position, only if it's
+     * marked as invalid.
+     */
+    public void removeInvalidTileEntity(BlockPos pos)
+    {
+        if (loaded)
+        {
+            TileEntity entity = (TileEntity)tileEntities.get(pos);
+            if (entity != null && entity.isInvalid())
+            {
+                tileEntities.remove(pos);
+            }
+        }
+    }
+
+    private static ChunkPos populating = null; // keep track of cascading chunk generation during chunk population
+
+    private void logCascadingWorldGeneration()
+    {
+        net.minecraftforge.fml.common.ModContainer activeModContainer = net.minecraftforge.fml.common.Loader.instance().activeModContainer();
+        String format = "{} loaded a new chunk {} in dimension {} ({}) while populating chunk {}, causing cascading worldgen lag.";
+
+        if (activeModContainer == null) { // vanilla minecraft has problems too (MC-114332), log it at a quieter level.
+            net.minecraftforge.fml.common.FMLLog.log.debug(format, "Minecraft", this.getPos(), this.world.provider.getDimension(), this.world.provider.getDimensionType().getName(), populating);
+            net.minecraftforge.fml.common.FMLLog.log.debug("Consider setting 'fixVanillaCascading' to 'true' in the Forge config to fix many cases where this occurs in the base game.");
+        } else {
+            net.minecraftforge.fml.common.FMLLog.log.warn(format, activeModContainer.getName(), this.getPos(), this.world.provider.getDimension(), this.world.provider.getDimensionType().getName(), populating);
+            net.minecraftforge.fml.common.FMLLog.log.warn("Please report this to the mod's issue tracker. This log can be disabled in the Forge config.");
+        }
+    }
+
+    private final net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
+    @Nullable
+    public net.minecraftforge.common.capabilities.CapabilityDispatcher getCapabilities()
+    {
+        return capabilities;
+    }
+    @Override
+    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing)
+    {
+        return capabilities == null ? false : capabilities.hasCapability(capability, facing);
+    }
+    @Override
+    @Nullable
+    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing)
+    {
+        return capabilities == null ? null : capabilities.getCapability(capability, facing);
     }
 }
