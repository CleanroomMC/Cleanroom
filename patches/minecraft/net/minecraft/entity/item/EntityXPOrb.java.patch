--- before/net/minecraft/entity/item/EntityXPOrb.java
+++ after/net/minecraft/entity/item/EntityXPOrb.java
@@ -141,17 +141,9 @@
 
         if (this.onGround)
         {
-            f = this.world
-                .getBlockState(
-                    new BlockPos(
-                        MathHelper.floor(this.posX),
-                        MathHelper.floor(this.getEntityBoundingBox().minY) - 1,
-                        MathHelper.floor(this.posZ)
-                    )
-                )
-                .getBlock()
-                .slipperiness
-                * 0.98F;
+            BlockPos underPos = new BlockPos(MathHelper.floor(this.posX), MathHelper.floor(this.getEntityBoundingBox().minY) - 1, MathHelper.floor(this.posZ));
+            net.minecraft.block.state.IBlockState underState = this.world.getBlockState(underPos);
+            f = underState.getBlock().getSlipperiness(underState, this.world, underPos, this) * 0.98F;
         }
 
         this.motionX *= (double)f;
@@ -187,6 +179,7 @@
     @Override
     public boolean attackEntityFrom(DamageSource source, float amount)
     {
+        if (this.world.isRemote || this.isDead) return false; //Forge: Fixes MC-53850
         if (this.isEntityInvulnerable(source))
         {
             return false;
@@ -228,13 +221,15 @@
         {
             if (this.delayBeforeCanPickup == 0 && entityIn.xpCooldown == 0)
             {
+                if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.player.PlayerPickupXpEvent(entityIn, this))) return;
                 entityIn.xpCooldown = 2;
                 entityIn.onItemPickup(this, 1);
                 ItemStack itemstack = EnchantmentHelper.getEnchantedItem(Enchantments.MENDING, entityIn);
 
                 if (!itemstack.isEmpty() && itemstack.isItemDamaged())
                 {
-                    int i = Math.min(this.xpToDurability(this.xpValue), itemstack.getItemDamage());
+                    float ratio = itemstack.getItem().getXpRepairRatio(itemstack);
+                    int i = Math.min(roundAverage(this.xpValue * ratio), itemstack.getItemDamage());
                     this.xpValue = this.xpValue - this.durabilityToXp(i);
                     itemstack.setItemDamage(itemstack.getItemDamage() - i);
                 }
@@ -357,5 +352,11 @@
     public boolean canBeAttackedWithItem()
     {
         return false;
+    }
+
+    private static int roundAverage(float value)
+    {
+        double floor = Math.floor(value);
+        return (int) floor + (Math.random() < value - floor ? 1 : 0);
     }
 }
