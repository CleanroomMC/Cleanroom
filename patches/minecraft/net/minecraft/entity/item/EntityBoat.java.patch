--- before/net/minecraft/entity/item/EntityBoat.java
+++ after/net/minecraft/entity/item/EntityBoat.java
@@ -39,16 +39,12 @@
 
 public class EntityBoat extends Entity
 {
-    private static final DataParameter<Integer> TIME_SINCE_HIT = EntityDataManager.createKey(EntityBoat.class, DataSerializers.VARINT);
-    private static final DataParameter<Integer> FORWARD_DIRECTION = EntityDataManager.createKey(EntityBoat.class, DataSerializers.VARINT);
-    private static final DataParameter<Float> DAMAGE_TAKEN = EntityDataManager.createKey(EntityBoat.class, DataSerializers.FLOAT);
-    private static final DataParameter<Integer> BOAT_TYPE = EntityDataManager.createKey(EntityBoat.class, DataSerializers.VARINT);
-    private static final DataParameter<Boolean>[] DATA_ID_PADDLE = new DataParameter[]
-        {
-            EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN),
-            EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN)
-        };
-    private final float[] paddlePositions = new float[2];
+    private static final DataParameter<Integer> TIME_SINCE_HIT = EntityDataManager.<Integer>createKey(EntityBoat.class, DataSerializers.VARINT);
+    private static final DataParameter<Integer> FORWARD_DIRECTION = EntityDataManager.<Integer>createKey(EntityBoat.class, DataSerializers.VARINT);
+    private static final DataParameter<Float> DAMAGE_TAKEN = EntityDataManager.<Float>createKey(EntityBoat.class, DataSerializers.FLOAT);
+    private static final DataParameter<Integer> BOAT_TYPE = EntityDataManager.<Integer>createKey(EntityBoat.class, DataSerializers.VARINT);
+    private static final DataParameter<Boolean>[] DATA_ID_PADDLE = new DataParameter[] {EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN), EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN)};
+    private final float[] paddlePositions;
     private float momentum;
     private float outOfControlTicks;
     private float deltaRotation;
@@ -71,6 +67,7 @@
     public EntityBoat(World worldIn)
     {
         super(worldIn);
+        this.paddlePositions = new float[2];
         this.preventEntitySpawning = true;
         this.setSize(1.375F, 0.5625F);
     }
@@ -79,98 +76,93 @@
     {
         this(worldIn);
         this.setPosition(x, y, z);
-        this.motionX = 0.0;
-        this.motionY = 0.0;
-        this.motionZ = 0.0;
+        this.motionX = 0.0D;
+        this.motionY = 0.0D;
+        this.motionZ = 0.0D;
         this.prevPosX = x;
         this.prevPosY = y;
         this.prevPosZ = z;
     }
 
-    @Override
     protected boolean canTriggerWalking()
     {
         return false;
     }
 
-    @Override
     protected void entityInit()
     {
-        this.dataManager.register(TIME_SINCE_HIT, 0);
-        this.dataManager.register(FORWARD_DIRECTION, 1);
-        this.dataManager.register(DAMAGE_TAKEN, 0.0F);
-        this.dataManager.register(BOAT_TYPE, EntityBoat.Type.OAK.ordinal());
+        this.dataManager.register(TIME_SINCE_HIT, Integer.valueOf(0));
+        this.dataManager.register(FORWARD_DIRECTION, Integer.valueOf(1));
+        this.dataManager.register(DAMAGE_TAKEN, Float.valueOf(0.0F));
+        this.dataManager.register(BOAT_TYPE, Integer.valueOf(EntityBoat.Type.OAK.ordinal()));
 
         for (DataParameter<Boolean> dataparameter : DATA_ID_PADDLE)
         {
-            this.dataManager.register(dataparameter, false);
+            this.dataManager.register(dataparameter, Boolean.valueOf(false));
         }
     }
 
     @Nullable
-    @Override
     public AxisAlignedBB getCollisionBox(Entity entityIn)
     {
         return entityIn.canBePushed() ? entityIn.getEntityBoundingBox() : null;
     }
 
     @Nullable
-    @Override
     public AxisAlignedBB getCollisionBoundingBox()
     {
         return this.getEntityBoundingBox();
     }
 
-    @Override
     public boolean canBePushed()
     {
         return true;
     }
 
-    @Override
     public double getMountedYOffset()
     {
-        return -0.1;
+        return -0.1D;
     }
 
-    @Override
     public boolean attackEntityFrom(DamageSource source, float amount)
     {
         if (this.isEntityInvulnerable(source))
         {
             return false;
         }
-        else if (this.world.isRemote || this.isDead)
-        {
-            return true;
-        }
-        else if (source instanceof EntityDamageSourceIndirect && source.getTrueSource() != null && this.isPassenger(source.getTrueSource()))
-        {
-            return false;
-        }
-        else
-        {
-            this.setForwardDirection(-this.getForwardDirection());
-            this.setTimeSinceHit(10);
-            this.setDamageTaken(this.getDamageTaken() + amount * 10.0F);
-            this.markVelocityChanged();
-            boolean flag = source.getTrueSource() instanceof EntityPlayer && ((EntityPlayer)source.getTrueSource()).capabilities.isCreativeMode;
+        else if (!this.world.isRemote && !this.isDead)
+        {
+            if (source instanceof EntityDamageSourceIndirect && source.getTrueSource() != null && this.isPassenger(source.getTrueSource()))
+            {
+                return false;
+            }
+            else
+            {
+                this.setForwardDirection(-this.getForwardDirection());
+                this.setTimeSinceHit(10);
+                this.setDamageTaken(this.getDamageTaken() + amount * 10.0F);
+                this.markVelocityChanged();
+                boolean flag = source.getTrueSource() instanceof EntityPlayer && ((EntityPlayer)source.getTrueSource()).capabilities.isCreativeMode;
 
-            if (flag || this.getDamageTaken() > 40.0F)
-            {
-                if (!flag && this.world.getGameRules().getBoolean("doEntityDrops"))
+                if (flag || this.getDamageTaken() > 40.0F)
                 {
-                    this.dropItemWithOffset(this.getItemBoat(), 1, 0.0F);
+                    if (!flag && this.world.getGameRules().getBoolean("doEntityDrops"))
+                    {
+                        this.dropItemWithOffset(this.getItemBoat(), 1, 0.0F);
+                    }
+
+                    this.setDead();
                 }
 
-                this.setDead();
+                return true;
             }
-
+        }
+        else
+        {
             return true;
         }
     }
 
-    @Override
     public void applyEntityCollision(Entity entityIn)
     {
         if (entityIn instanceof EntityBoat)
@@ -207,7 +199,6 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public void performHurtAnimation()
     {
         this.setForwardDirection(-this.getForwardDirection());
@@ -215,17 +206,13 @@
         this.setDamageTaken(this.getDamageTaken() * 11.0F);
     }
 
-    @Override
     public boolean canBeCollidedWith()
     {
         return !this.isDead;
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
-    public void setPositionAndRotationDirect(
-        double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport
-    )
+    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
     {
         this.lerpX = x;
         this.lerpY = y;
@@ -235,13 +222,11 @@
         this.lerpSteps = 10;
     }
 
-    @Override
     public EnumFacing getAdjustedHorizontalFacing()
     {
         return this.getHorizontalFacing().rotateY();
     }
 
-    @Override
     public void onUpdate()
     {
         this.previousStatus = this.status;
@@ -253,7 +238,7 @@
         }
         else
         {
-            this.outOfControlTicks++;
+            ++this.outOfControlTicks;
         }
 
         if (!this.world.isRemote && this.outOfControlTicks >= 60.0F)
@@ -296,18 +281,16 @@
         }
         else
         {
-            this.motionX = 0.0;
-            this.motionY = 0.0;
-            this.motionZ = 0.0;
+            this.motionX = 0.0D;
+            this.motionY = 0.0D;
+            this.motionZ = 0.0D;
         }
 
-        for (int i = 0; i <= 1; i++)
+        for (int i = 0; i <= 1; ++i)
         {
             if (this.getPaddleState(i))
             {
-                if (!this.isSilent()
-                        && (double)(this.paddlePositions[i] % (float)(Math.PI * 2)) <= (float)(Math.PI / 4)
-                        && ((double)this.paddlePositions[i] + (float)(Math.PI / 8)) % (float)(Math.PI * 2) >= (float)(Math.PI / 4))
+                if (!this.isSilent() && (double)(this.paddlePositions[i] % ((float)Math.PI * 2F)) <= (Math.PI / 4D) && ((double)this.paddlePositions[i] + 0.39269909262657166D) % (Math.PI * 2D) >= (Math.PI / 4D))
                 {
                     SoundEvent soundevent = this.getPaddleSound();
 
@@ -316,21 +299,11 @@
                         Vec3d vec3d = this.getLook(1.0F);
                         double d0 = i == 1 ? -vec3d.z : vec3d.z;
                         double d1 = i == 1 ? vec3d.x : -vec3d.x;
-                        this.world
-                        .playSound(
-                            null,
-                            this.posX + d0,
-                            this.posY,
-                            this.posZ + d1,
-                            soundevent,
-                            this.getSoundCategory(),
-                            1.0F,
-                            0.8F + 0.4F * this.rand.nextFloat()
-                        );
+                        this.world.playSound((EntityPlayer)null, this.posX + d0, this.posY, this.posZ + d1, soundevent, this.getSoundCategory(), 1.0F, 0.8F + 0.4F * this.rand.nextFloat());
                     }
                 }
 
-                this.paddlePositions[i] = (float)((double)this.paddlePositions[i] + (float)(Math.PI / 8));
+                this.paddlePositions[i] = (float)((double)this.paddlePositions[i] + 0.39269909262657166D);
             }
             else
             {
@@ -339,25 +312,19 @@
         }
 
         this.doBlockCollisions();
-        List<Entity> list = this.world.getEntitiesInAABBexcluding(this, this.getEntityBoundingBox().grow(0.2F, -0.01F, 0.2F), EntitySelectors.getTeamCollisionPredicate(this));
+        List<Entity> list = this.world.getEntitiesInAABBexcluding(this, this.getEntityBoundingBox().grow(0.20000000298023224D, -0.009999999776482582D, 0.20000000298023224D), EntitySelectors.getTeamCollisionPredicate(this));
 
         if (!list.isEmpty())
         {
             boolean flag = !this.world.isRemote && !(this.getControllingPassenger() instanceof EntityPlayer);
 
-            for (int j = 0; j < list.size(); j++)
+            for (int j = 0; j < list.size(); ++j)
             {
                 Entity entity = list.get(j);
 
                 if (!entity.isPassenger(this))
                 {
-                    if (flag
-                            && this.getPassengers().size() < 2
-                            && !entity.isRiding()
-                            && entity.width < this.width
-                            && entity instanceof EntityLivingBase
-                            && !(entity instanceof EntityWaterMob)
-                            && !(entity instanceof EntityPlayer))
+                    if (flag && this.getPassengers().size() < 2 && !entity.isRiding() && entity.width < this.width && entity instanceof EntityLivingBase && !(entity instanceof EntityWaterMob) && !(entity instanceof EntityPlayer))
                     {
                         entity.startRiding(this);
                     }
@@ -397,7 +364,7 @@
             double d3 = MathHelper.wrapDegrees(this.lerpYaw - (double)this.rotationYaw);
             this.rotationYaw = (float)((double)this.rotationYaw + d3 / (double)this.lerpSteps);
             this.rotationPitch = (float)((double)this.rotationPitch + (this.lerpPitch - (double)this.rotationPitch) / (double)this.lerpSteps);
-            this.lerpSteps--;
+            --this.lerpSteps;
             this.setPosition(d0, d1, d2);
             this.setRotation(this.rotationYaw, this.rotationPitch);
         }
@@ -405,18 +372,14 @@
 
     public void setPaddleState(boolean left, boolean right)
     {
-        this.dataManager.set(DATA_ID_PADDLE[0], left);
-        this.dataManager.set(DATA_ID_PADDLE[1], right);
+        this.dataManager.set(DATA_ID_PADDLE[0], Boolean.valueOf(left));
+        this.dataManager.set(DATA_ID_PADDLE[1], Boolean.valueOf(right));
     }
 
     @SideOnly(Side.CLIENT)
     public float getRowingTime(int side, float limbSwing)
     {
-        return this.getPaddleState(side)
-               ? (float)MathHelper.clampedLerp(
-                   (double)this.paddlePositions[side] - (float)(Math.PI / 8), (double)this.paddlePositions[side], (double)limbSwing
-               )
-               : 0.0F;
+        return this.getPaddleState(side) ? (float)MathHelper.clampedLerp((double)this.paddlePositions[side] - 0.39269909262657166D, (double)this.paddlePositions[side], (double)limbSwing) : 0.0F;
     }
 
     private EntityBoat.Status getBoatStatus()
@@ -461,48 +424,54 @@
 
         try
         {
-            label87:
+            label108:
 
-            for (int k1 = k; k1 < l; k1++)
+            for (int k1 = k; k1 < l; ++k1)
             {
                 float f = 0.0F;
                 int l1 = i;
 
                 while (true)
                 {
-                    if (l1 < j)
-                    {
-                        for (int i2 = i1; i2 < j1; i2++)
-                        {
-                            blockpos$pooledmutableblockpos.setPos(l1, k1, i2);
-                            IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
-
-                            if (iblockstate.getMaterial() == Material.WATER)
-                            {
-                                f = Math.max(f, BlockLiquid.getBlockLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos));
-                            }
-
-                            if (f >= 1.0F)
-                            {
-                                continue label87;
-                            }
-                        }
-
-                        l1++;
-                    }
-                    else
+                    if (l1 >= j)
                     {
                         if (f < 1.0F)
                         {
-                            return (float)blockpos$pooledmutableblockpos.getY() + f;
+                            float f2 = (float)blockpos$pooledmutableblockpos.getY() + f;
+                            return f2;
                         }
 
                         break;
                     }
+
+                    for (int i2 = i1; i2 < j1; ++i2)
+                    {
+                        blockpos$pooledmutableblockpos.setPos(l1, k1, i2);
+                        IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
+
+                        Boolean result = iblockstate.getBlock().isAABBInsideMaterial(world, blockpos$pooledmutableblockpos, new AxisAlignedBB(blockpos$pooledmutableblockpos), Material.WATER);
+                        if (result != null) {
+                            if (!result) continue;
+                            f = Math.max(f, iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) + blockpos$pooledmutableblockpos.getY());
+                        }
+
+                        if (iblockstate.getMaterial() == Material.WATER)
+                        {
+                            f = Math.max(f, BlockLiquid.getBlockLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos));
+                        }
+
+                        if (f >= 1.0F)
+                        {
+                            continue label108;
+                        }
+                    }
+
+                    ++l1;
                 }
             }
 
-            return (float)(l + 1);
+            float f1 = (float)(l + 1);
+            return f1;
         }
         finally
         {
@@ -513,36 +482,29 @@
     public float getBoatGlide()
     {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
-        AxisAlignedBB axisalignedbb1 = new AxisAlignedBB(
-            axisalignedbb.minX,
-            axisalignedbb.minY - 0.001,
-            axisalignedbb.minZ,
-            axisalignedbb.maxX,
-            axisalignedbb.minY,
-            axisalignedbb.maxZ
-        );
+        AxisAlignedBB axisalignedbb1 = new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY - 0.001D, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxZ);
         int i = MathHelper.floor(axisalignedbb1.minX) - 1;
         int j = MathHelper.ceil(axisalignedbb1.maxX) + 1;
         int k = MathHelper.floor(axisalignedbb1.minY) - 1;
         int l = MathHelper.ceil(axisalignedbb1.maxY) + 1;
         int i1 = MathHelper.floor(axisalignedbb1.minZ) - 1;
         int j1 = MathHelper.ceil(axisalignedbb1.maxZ) + 1;
-        List<AxisAlignedBB> list = Lists.newArrayList();
+        List<AxisAlignedBB> list = Lists.<AxisAlignedBB>newArrayList();
         float f = 0.0F;
         int k1 = 0;
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
         try
         {
-            for (int l1 = i; l1 < j; l1++)
+            for (int l1 = i; l1 < j; ++l1)
             {
-                for (int i2 = i1; i2 < j1; i2++)
+                for (int i2 = i1; i2 < j1; ++i2)
                 {
                     int j2 = (l1 != i && l1 != j - 1 ? 0 : 1) + (i2 != i1 && i2 != j1 - 1 ? 0 : 1);
 
                     if (j2 != 2)
                     {
-                        for (int k2 = k; k2 < l; k2++)
+                        for (int k2 = k; k2 < l; ++k2)
                         {
                             if (j2 <= 0 || k2 != k && k2 != l - 1)
                             {
@@ -552,8 +514,8 @@
 
                                 if (!list.isEmpty())
                                 {
-                                    f += iblockstate.getBlock().slipperiness;
-                                    k1++;
+                                    f += iblockstate.getBlock().getSlipperiness(iblockstate, this.world, blockpos$pooledmutableblockpos, this);
+                                    ++k1;
                                 }
 
                                 list.clear();
@@ -577,7 +539,7 @@
         int i = MathHelper.floor(axisalignedbb.minX);
         int j = MathHelper.ceil(axisalignedbb.maxX);
         int k = MathHelper.floor(axisalignedbb.minY);
-        int l = MathHelper.ceil(axisalignedbb.minY + 0.001);
+        int l = MathHelper.ceil(axisalignedbb.minY + 0.001D);
         int i1 = MathHelper.floor(axisalignedbb.minZ);
         int j1 = MathHelper.ceil(axisalignedbb.maxZ);
         boolean flag = false;
@@ -586,14 +548,23 @@
 
         try
         {
-            for (int k1 = i; k1 < j; k1++)
+            for (int k1 = i; k1 < j; ++k1)
             {
-                for (int l1 = k; l1 < l; l1++)
+                for (int l1 = k; l1 < l; ++l1)
                 {
-                    for (int i2 = i1; i2 < j1; i2++)
+                    for (int i2 = i1; i2 < j1; ++i2)
                     {
                         blockpos$pooledmutableblockpos.setPos(k1, l1, i2);
                         IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
+
+                        Boolean result = iblockstate.getBlock().isAABBInsideMaterial(world, blockpos$pooledmutableblockpos, axisalignedbb, Material.WATER);
+                        if (result != null) {
+                            if (!result) continue;
+                            
+                            float f = iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) + blockpos$pooledmutableblockpos.getY();
+                            this.waterLevel = Math.max((double)f, this.waterLevel);
+                            flag |= axisalignedbb.minY < (double)f;
+                        }
 
                         if (iblockstate.getMaterial() == Material.WATER)
                         {
@@ -617,7 +588,7 @@
     private EntityBoat.Status getUnderwaterStatus()
     {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
-        double d0 = axisalignedbb.maxY + 0.001;
+        double d0 = axisalignedbb.maxY + 0.001D;
         int i = MathHelper.floor(axisalignedbb.minX);
         int j = MathHelper.ceil(axisalignedbb.maxX);
         int k = MathHelper.floor(axisalignedbb.maxY);
@@ -629,21 +600,33 @@
 
         try
         {
-            for (int k1 = i; k1 < j; k1++)
+            for (int k1 = i; k1 < j; ++k1)
             {
-                for (int l1 = k; l1 < l; l1++)
+                for (int l1 = k; l1 < l; ++l1)
                 {
-                    for (int i2 = i1; i2 < j1; i2++)
+                    for (int i2 = i1; i2 < j1; ++i2)
                     {
                         blockpos$pooledmutableblockpos.setPos(k1, l1, i2);
                         IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
 
-                        if (iblockstate.getMaterial() == Material.WATER
-                                && d0 < (double)BlockLiquid.getLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos))
-                        {
-                            if (iblockstate.getValue(BlockLiquid.LEVEL) != 0)
-                            {
+                        Boolean result = iblockstate.getBlock().isAABBInsideMaterial(world, blockpos$pooledmutableblockpos, axisalignedbb, Material.WATER);
+                        if (result != null) {
+                            if (!result) continue;
+                            
+                            if(iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) > 0)
+                            {   
+                                blockpos$pooledmutableblockpos.release();
                                 return EntityBoat.Status.UNDER_FLOWING_WATER;
+                            } else
+                                continue;
+                        }
+
+                        if (iblockstate.getMaterial() == Material.WATER && d0 < (double)BlockLiquid.getLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos))
+                        {
+                            if (((Integer)iblockstate.getValue(BlockLiquid.LEVEL)).intValue() != 0)
+                            {
+                                EntityBoat.Status entityboat$status = EntityBoat.Status.UNDER_FLOWING_WATER;
+                                return entityboat$status;
                             }
 
                             flag = true;
@@ -662,19 +645,17 @@
 
     private void updateMotion()
     {
-        double d0 = -0.04F;
-        double d1 = this.hasNoGravity() ? 0.0 : -0.04F;
-        double d2 = 0.0;
+        double d0 = -0.03999999910593033D;
+        double d1 = this.hasNoGravity() ? 0.0D : -0.03999999910593033D;
+        double d2 = 0.0D;
         this.momentum = 0.05F;
 
-        if (this.previousStatus == EntityBoat.Status.IN_AIR
-                && this.status != EntityBoat.Status.IN_AIR
-                && this.status != EntityBoat.Status.ON_LAND)
+        if (this.previousStatus == EntityBoat.Status.IN_AIR && this.status != EntityBoat.Status.IN_AIR && this.status != EntityBoat.Status.ON_LAND)
         {
             this.waterLevel = this.getEntityBoundingBox().minY + (double)this.height;
-            this.setPosition(this.posX, (double)(this.getWaterLevelAbove() - this.height) + 0.101, this.posZ);
-            this.motionY = 0.0;
-            this.lastYd = 0.0;
+            this.setPosition(this.posX, (double)(this.getWaterLevelAbove() - this.height) + 0.101D, this.posZ);
+            this.motionY = 0.0D;
+            this.lastYd = 0.0D;
             this.status = EntityBoat.Status.IN_WATER;
         }
         else
@@ -686,12 +667,12 @@
             }
             else if (this.status == EntityBoat.Status.UNDER_FLOWING_WATER)
             {
-                d1 = -7.0E-4;
+                d1 = -7.0E-4D;
                 this.momentum = 0.9F;
             }
             else if (this.status == EntityBoat.Status.UNDER_WATER)
             {
-                d2 = 0.01F;
+                d2 = 0.009999999776482582D;
                 this.momentum = 0.45F;
             }
             else if (this.status == EntityBoat.Status.IN_AIR)
@@ -708,17 +689,17 @@
                 }
             }
 
-            this.motionX = this.motionX * (double)this.momentum;
-            this.motionZ = this.motionZ * (double)this.momentum;
-            this.deltaRotation = this.deltaRotation * this.momentum;
+            this.motionX *= (double)this.momentum;
+            this.motionZ *= (double)this.momentum;
+            this.deltaRotation *= this.momentum;
             this.motionY += d1;
 
-            if (d2 > 0.0)
+            if (d2 > 0.0D)
             {
-                double d3 = 0.65;
-                this.motionY += d2 * 0.06153846016296973;
-                double d4 = 0.75;
-                this.motionY *= 0.75;
+                double d3 = 0.65D;
+                this.motionY += d2 * 0.06153846016296973D;
+                double d4 = 0.75D;
+                this.motionY *= 0.75D;
             }
         }
     }
@@ -736,7 +717,7 @@
 
             if (this.rightInputDown)
             {
-                this.deltaRotation++;
+                ++this.deltaRotation;
             }
 
             if (this.rightInputDown != this.leftInputDown && !this.forwardInputDown && !this.backInputDown)
@@ -744,7 +725,7 @@
                 f += 0.005F;
             }
 
-            this.rotationYaw = this.rotationYaw + this.deltaRotation;
+            this.rotationYaw += this.deltaRotation;
 
             if (this.forwardInputDown)
             {
@@ -756,21 +737,18 @@
                 f -= 0.005F;
             }
 
-            this.motionX = this.motionX + (double)(MathHelper.sin(-this.rotationYaw * (float)(Math.PI / 180.0)) * f);
-            this.motionZ = this.motionZ + (double)(MathHelper.cos(this.rotationYaw * (float)(Math.PI / 180.0)) * f);
-            this.setPaddleState(
-                this.rightInputDown && !this.leftInputDown || this.forwardInputDown, this.leftInputDown && !this.rightInputDown || this.forwardInputDown
-            );
+            this.motionX += (double)(MathHelper.sin(-this.rotationYaw * 0.017453292F) * f);
+            this.motionZ += (double)(MathHelper.cos(this.rotationYaw * 0.017453292F) * f);
+            this.setPaddleState(this.rightInputDown && !this.leftInputDown || this.forwardInputDown, this.leftInputDown && !this.rightInputDown || this.forwardInputDown);
         }
     }
 
-    @Override
     public void updatePassenger(Entity passenger)
     {
         if (this.isPassenger(passenger))
         {
             float f = 0.0F;
-            float f1 = (float)((this.isDead ? 0.01F : this.getMountedYOffset()) + passenger.getYOffset());
+            float f1 = (float)((this.isDead ? 0.009999999776482582D : this.getMountedYOffset()) + passenger.getYOffset());
 
             if (this.getPassengers().size() > 1)
             {
@@ -787,13 +765,13 @@
 
                 if (passenger instanceof EntityAnimal)
                 {
-                    f = (float)((double)f + 0.2);
+                    f = (float)((double)f + 0.2D);
                 }
             }
 
-            Vec3d vec3d = new Vec3d((double)f, 0.0, 0.0).rotateYaw(-this.rotationYaw * (float)(Math.PI / 180.0) - (float)(Math.PI / 2));
+            Vec3d vec3d = (new Vec3d((double)f, 0.0D, 0.0D)).rotateYaw(-this.rotationYaw * 0.017453292F - ((float)Math.PI / 2F));
             passenger.setPosition(this.posX + vec3d.x, this.posY + (double)f1, this.posZ + vec3d.z);
-            passenger.rotationYaw = passenger.rotationYaw + this.deltaRotation;
+            passenger.rotationYaw += this.deltaRotation;
             passenger.setRotationYawHead(passenger.getRotationYawHead() + this.deltaRotation);
             this.applyYawToEntity(passenger);
 
@@ -817,19 +795,16 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public void applyOrientationToEntity(Entity entityToUpdate)
     {
         this.applyYawToEntity(entityToUpdate);
     }
 
-    @Override
     protected void writeEntityToNBT(NBTTagCompound compound)
     {
         compound.setString("Type", this.getBoatType().getName());
     }
 
-    @Override
     protected void readEntityFromNBT(NBTTagCompound compound)
     {
         if (compound.hasKey("Type", 8))
@@ -838,7 +813,6 @@
         }
     }
 
-    @Override
     public boolean processInitialInteract(EntityPlayer player, EnumHand hand)
     {
         if (player.isSneaking())
@@ -856,7 +830,6 @@
         }
     }
 
-    @Override
     protected void updateFallState(double y, boolean onGroundIn, IBlockState state, BlockPos pos)
     {
         this.lastYd = this.motionY;
@@ -881,12 +854,12 @@
 
                         if (this.world.getGameRules().getBoolean("doEntityDrops"))
                         {
-                            for (int i = 0; i < 3; i++)
+                            for (int i = 0; i < 3; ++i)
                             {
                                 this.entityDropItem(new ItemStack(Item.getItemFromBlock(Blocks.PLANKS), 1, this.getBoatType().getMetadata()), 0.0F);
                             }
 
-                            for (int j = 0; j < 2; j++)
+                            for (int j = 0; j < 2; ++j)
                             {
                                 this.dropItemWithOffset(Items.STICK, 1, 0.0F);
                             }
@@ -896,7 +869,7 @@
 
                 this.fallDistance = 0.0F;
             }
-            else if (this.world.getBlockState(new BlockPos(this).down()).getMaterial() != Material.WATER && y < 0.0)
+            else if (this.world.getBlockState((new BlockPos(this)).down()).getMaterial() != Material.WATER && y < 0.0D)
             {
                 this.fallDistance = (float)((double)this.fallDistance - y);
             }
@@ -905,61 +878,59 @@
 
     public boolean getPaddleState(int side)
     {
-        return this.dataManager.get(DATA_ID_PADDLE[side]) && this.getControllingPassenger() != null;
+        return ((Boolean)this.dataManager.get(DATA_ID_PADDLE[side])).booleanValue() && this.getControllingPassenger() != null;
     }
 
     public void setDamageTaken(float damageTaken)
     {
-        this.dataManager.set(DAMAGE_TAKEN, damageTaken);
+        this.dataManager.set(DAMAGE_TAKEN, Float.valueOf(damageTaken));
     }
 
     public float getDamageTaken()
     {
-        return this.dataManager.get(DAMAGE_TAKEN);
+        return ((Float)this.dataManager.get(DAMAGE_TAKEN)).floatValue();
     }
 
     public void setTimeSinceHit(int timeSinceHit)
     {
-        this.dataManager.set(TIME_SINCE_HIT, timeSinceHit);
+        this.dataManager.set(TIME_SINCE_HIT, Integer.valueOf(timeSinceHit));
     }
 
     public int getTimeSinceHit()
     {
-        return this.dataManager.get(TIME_SINCE_HIT);
+        return ((Integer)this.dataManager.get(TIME_SINCE_HIT)).intValue();
     }
 
     public void setForwardDirection(int forwardDirection)
     {
-        this.dataManager.set(FORWARD_DIRECTION, forwardDirection);
+        this.dataManager.set(FORWARD_DIRECTION, Integer.valueOf(forwardDirection));
     }
 
     public int getForwardDirection()
     {
-        return this.dataManager.get(FORWARD_DIRECTION);
+        return ((Integer)this.dataManager.get(FORWARD_DIRECTION)).intValue();
     }
 
     public void setBoatType(EntityBoat.Type boatType)
     {
-        this.dataManager.set(BOAT_TYPE, boatType.ordinal());
+        this.dataManager.set(BOAT_TYPE, Integer.valueOf(boatType.ordinal()));
     }
 
     public EntityBoat.Type getBoatType()
     {
-        return EntityBoat.Type.byId(this.dataManager.get(BOAT_TYPE));
+        return EntityBoat.Type.byId(((Integer)this.dataManager.get(BOAT_TYPE)).intValue());
     }
 
-    @Override
     protected boolean canFitPassenger(Entity passenger)
     {
         return this.getPassengers().size() < 2;
     }
 
     @Nullable
-    @Override
     public Entity getControllingPassenger()
     {
         List<Entity> list = this.getPassengers();
-        return list.isEmpty() ? null : list.get(0);
+        return list.isEmpty() ? null : (Entity)list.get(0);
     }
 
     @SideOnly(Side.CLIENT)
@@ -1008,7 +979,6 @@
             return this.metadata;
         }
 
-        @Override
         public String toString()
         {
             return this.name;
@@ -1026,7 +996,7 @@
 
         public static EntityBoat.Type getTypeFromString(String nameIn)
         {
-            for (int i = 0; i < values().length; i++)
+            for (int i = 0; i < values().length; ++i)
             {
                 if (values()[i].getName().equals(nameIn))
                 {
@@ -1035,6 +1005,22 @@
             }
 
             return values()[0];
+        }
+    }
+
+    // Forge: Fix MC-119811 by instantly completing lerp on board
+    @Override
+    protected void addPassenger(Entity passenger)
+    {
+        super.addPassenger(passenger);
+        if(this.canPassengerSteer() && this.lerpSteps > 0)
+        {
+            this.lerpSteps = 0;
+            this.posX = this.lerpX;
+            this.posY = this.lerpY;
+            this.posZ = this.lerpZ;
+            this.rotationYaw = (float)this.lerpYaw;
+            this.rotationPitch = (float)this.lerpPitch;
         }
     }
 }
