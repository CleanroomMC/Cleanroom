--- before/net/minecraft/entity/item/EntityMinecart.java
+++ after/net/minecraft/entity/item/EntityMinecart.java
@@ -71,6 +71,20 @@
     @SideOnly(Side.CLIENT)
     private double velocityZ;
 
+    /* Forge: Minecart Compatibility Layer Integration. */
+    public static float defaultMaxSpeedAirLateral = 0.4f;
+    public static float defaultMaxSpeedAirVertical = -1f;
+    public static double defaultDragAir = 0.95;
+    protected boolean canUseRail = true;
+    protected boolean canBePushed = true;
+    private static net.minecraftforge.common.IMinecartCollisionHandler collisionHandler = null;
+
+    /* Instance versions of the above physics properties */
+    private float currentSpeedRail = getMaxCartSpeedOnRail();
+    protected float maxSpeedAirLateral = defaultMaxSpeedAirLateral;
+    protected float maxSpeedAirVertical = defaultMaxSpeedAirVertical;
+    protected double dragAir = defaultDragAir;
+
     public EntityMinecart(World worldIn)
     {
         super(worldIn);
@@ -120,6 +134,7 @@
     @Override
     public AxisAlignedBB getCollisionBox(Entity entityIn)
     {
+        if (getCollisionHandler() != null) return getCollisionHandler().getCollisionBox(this, entityIn);
         return entityIn.canBePushed() ? entityIn.getEntityBoundingBox() : null;
     }
 
@@ -127,13 +142,14 @@
     @Override
     public AxisAlignedBB getCollisionBoundingBox()
     {
+        if (getCollisionHandler() != null) return getCollisionHandler().getBoundingBox(this);
         return null;
     }
 
     @Override
     public boolean canBePushed()
     {
-        return true;
+        return canBePushed;
     }
 
     public EntityMinecart(World worldIn, double x, double y, double z)
@@ -342,7 +358,7 @@
             BlockPos blockpos = new BlockPos(k, l, i1);
             IBlockState iblockstate = this.world.getBlockState(blockpos);
 
-            if (BlockRailBase.isRailBlock(iblockstate))
+            if (canUseRail() && BlockRailBase.isRailBlock(iblockstate))
             {
                 this.moveAlongTrack(blockpos, iblockstate);
 
@@ -381,10 +397,14 @@
 
             this.setRotation(this.rotationYaw, this.rotationPitch);
 
-            if (this.getType() == EntityMinecart.Type.RIDEABLE && this.motionX * this.motionX + this.motionZ * this.motionZ > 0.01)
+            AxisAlignedBB box;
+            if (getCollisionHandler() != null) box = getCollisionHandler().getMinecartCollisionBox(this);
+            else                               box = this.getEntityBoundingBox().grow(0.2F, 0.0, 0.2F);
+
+            if (canBeRidden() && this.motionX * this.motionX + this.motionZ * this.motionZ > 0.01)
             {
                 List<Entity> list = this.world
-                                    .getEntitiesInAABBexcluding(this, this.getEntityBoundingBox().grow(0.2F, 0.0, 0.2F), EntitySelectors.getTeamCollisionPredicate(this));
+                                    .getEntitiesInAABBexcluding(this, box, EntitySelectors.getTeamCollisionPredicate(this));
 
                 if (!list.isEmpty())
                 {
@@ -409,7 +429,7 @@
             }
             else
             {
-                for (Entity entity : this.world.getEntitiesWithinAABBExcludingEntity(this, this.getEntityBoundingBox().grow(0.2F, 0.0, 0.2F)))
+                for (Entity entity : this.world.getEntitiesWithinAABBExcludingEntity(this, box))
                 {
                     if (!this.isPassenger(entity) && entity.canBePushed() && entity instanceof EntityMinecart)
                     {
@@ -419,6 +439,7 @@
             }
 
             this.handleWaterMovement();
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.minecart.MinecartUpdateEvent(this, this.getCurrentRailPosition()));
         }
     }
 
@@ -433,10 +454,21 @@
 
     protected void moveDerailedMinecart()
     {
-        double d0 = this.getMaximumSpeed();
+        double d0 = onGround ? this.getMaximumSpeed() : getMaxSpeedAirLateral();
         this.motionX = MathHelper.clamp(this.motionX, -d0, d0);
         this.motionZ = MathHelper.clamp(this.motionZ, -d0, d0);
 
+        double moveY = motionY;
+        if(getMaxSpeedAirVertical() > 0 && motionY > getMaxSpeedAirVertical())
+        {
+            moveY = getMaxSpeedAirVertical();
+            if(Math.abs(motionX) < 0.3f && Math.abs(motionZ) < 0.3f)
+            {
+                moveY = 0.15f;
+                motionY = moveY;
+            }
+        }
+
         if (this.onGround)
         {
             this.motionX *= 0.5;
@@ -444,13 +476,13 @@
             this.motionZ *= 0.5;
         }
 
-        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+        this.move(MoverType.SELF, this.motionX, moveY, this.motionZ);
 
         if (!this.onGround)
         {
-            this.motionX *= 0.95F;
-            this.motionY *= 0.95F;
-            this.motionZ *= 0.95F;
+            this.motionX *= getDragAir();
+            this.motionY *= getDragAir();
+            this.motionZ *= getDragAir();
         }
     }
 
@@ -470,25 +502,25 @@
             flag1 = !flag;
         }
 
-        double d0 = 0.0078125;
-        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = state.getValue(blockrailbase.getShapeProperty());
+        double slopeAdjustment = getSlopeAdjustment();
+        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = blockrailbase.getRailDirection(world, pos, state, this);
 
         switch (blockrailbase$enumraildirection)
         {
             case ASCENDING_EAST:
-                this.motionX -= 0.0078125;
+                this.motionX -= slopeAdjustment;
                 this.posY++;
                 break;
             case ASCENDING_WEST:
-                this.motionX += 0.0078125;
+                this.motionX += slopeAdjustment;
                 this.posY++;
                 break;
             case ASCENDING_NORTH:
-                this.motionZ += 0.0078125;
+                this.motionZ += slopeAdjustment;
                 this.posY++;
                 break;
             case ASCENDING_SOUTH:
-                this.motionZ -= 0.0078125;
+                this.motionZ -= slopeAdjustment;
                 this.posY++;
         }
 
@@ -521,8 +553,8 @@
 
             if (d6 > 0.0)
             {
-                double d7 = -Math.sin((double)(entity.rotationYaw * (float)(Math.PI / 180.0)));
-                double d8 = Math.cos((double)(entity.rotationYaw * (float)(Math.PI / 180.0)));
+                double d7 = -Math.sin((double)(entity.rotationYaw * 0.017453292F));
+                double d8 = Math.cos((double)(entity.rotationYaw * 0.017453292F));
                 double d9 = this.motionX * this.motionX + this.motionZ * this.motionZ;
 
                 if (d9 < 0.01)
@@ -534,7 +566,7 @@
             }
         }
 
-        if (flag1)
+        if (flag1 && shouldDoRailFunctions())
         {
             double d17 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 
@@ -580,23 +612,9 @@
         this.posX = d18 + d1 * d10;
         this.posZ = d19 + d2 * d10;
         this.setPosition(this.posX, this.posY, this.posZ);
-        double d22 = this.motionX;
-        double d23 = this.motionZ;
-
-        if (this.isBeingRidden())
-        {
-            d22 *= 0.75;
-            d23 *= 0.75;
-        }
-
-        double d13 = this.getMaximumSpeed();
-        d22 = MathHelper.clamp(d22, -d13, d13);
-        d23 = MathHelper.clamp(d23, -d13, d13);
-        this.move(MoverType.SELF, d22, 0.0, d23);
-
-        if (aint[0][1] != 0
-                && MathHelper.floor(this.posX) - pos.getX() == aint[0][0]
-                && MathHelper.floor(this.posZ) - pos.getZ() == aint[0][2])
+        this.moveMinecartOnRail(pos);
+
+        if (aint[0][1] != 0 && MathHelper.floor(this.posX) - pos.getX() == aint[0][0] && MathHelper.floor(this.posZ) - pos.getZ() == aint[0][2])
         {
             this.setPosition(this.posX, this.posY + (double)aint[0][1], this.posZ);
         }
@@ -634,7 +652,13 @@
             this.motionZ = d5 * (double)(i - pos.getZ());
         }
 
-        if (flag)
+
+        if(shouldDoRailFunctions())
+        {
+            ((BlockRailBase)state.getBlock()).onMinecartPass(world, this, pos);
+        }
+
+        if (flag && shouldDoRailFunctions())
         {
             double d15 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 
@@ -715,9 +739,7 @@
 
         if (BlockRailBase.isRailBlock(iblockstate))
         {
-            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = iblockstate.getValue(
-                        ((BlockRailBase)iblockstate.getBlock()).getShapeProperty()
-                    );
+            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = ((BlockRailBase)iblockstate.getBlock()).getRailDirection(world, new BlockPos(i, j, k), iblockstate, this);
             y = (double)j;
 
             if (blockrailbase$enumraildirection.isAscending())
@@ -767,9 +789,7 @@
 
         if (BlockRailBase.isRailBlock(iblockstate))
         {
-            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = iblockstate.getValue(
-                        ((BlockRailBase)iblockstate.getBlock()).getShapeProperty()
-                    );
+            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = ((BlockRailBase)iblockstate.getBlock()).getRailDirection(world, new BlockPos(i, j, k), iblockstate, this);
             int[][] aint = MATRIX[blockrailbase$enumraildirection.getMetadata()];
             double d0 = (double)i + 0.5 + (double)aint[0][0] * 0.5;
             double d1 = (double)j + 0.0625 + (double)aint[0][1] * 0.5;
@@ -870,6 +890,12 @@
     @Override
     public void applyEntityCollision(Entity entityIn)
     {
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.minecart.MinecartCollisionEvent(this, entityIn));
+        if (getCollisionHandler() != null)
+        {
+            getCollisionHandler().onEntityCollision(this, entityIn);
+            return;
+        }
         if (!this.world.isRemote)
         {
             if (!entityIn.noClip && !this.noClip)
@@ -922,7 +948,7 @@
                             double d7 = entityIn.motionX + this.motionX;
                             double d8 = entityIn.motionZ + this.motionZ;
 
-                            if (((EntityMinecart)entityIn).getType() == EntityMinecart.Type.FURNACE && this.getType() != EntityMinecart.Type.FURNACE)
+                            if (((EntityMinecart)entityIn).isPoweredCart() && !isPoweredCart())
                             {
                                 this.motionX *= 0.2F;
                                 this.motionZ *= 0.2F;
@@ -930,8 +956,7 @@
                                 entityIn.motionX *= 0.95F;
                                 entityIn.motionZ *= 0.95F;
                             }
-                            else if (((EntityMinecart)entityIn).getType() != EntityMinecart.Type.FURNACE
-                                     && this.getType() == EntityMinecart.Type.FURNACE)
+                            else if (!((EntityMinecart)entityIn).isPoweredCart() && isPoweredCart())
                             {
                                 entityIn.motionX *= 0.2F;
                                 entityIn.motionZ *= 0.2F;
@@ -963,10 +988,7 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
-    public void setPositionAndRotationDirect(
-        double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport
-    )
+    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
     {
         this.minecartX = x;
         this.minecartY = y;
@@ -1064,6 +1086,236 @@
     {
         this.getDataManager().set(SHOW_BLOCK, showBlock);
     }
+    
+    @Override
+    public boolean processInitialInteract(EntityPlayer player, net.minecraft.util.EnumHand hand)
+    {
+        return net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.minecart.MinecartInteractEvent(this, player, hand));
+    }
+
+    /* =================================== FORGE START ===========================================*/
+    private BlockPos getCurrentRailPosition()
+    {
+        int x = MathHelper.floor(this.posX);
+        int y = MathHelper.floor(this.posY);
+        int z = MathHelper.floor(this.posZ);
+
+        if (BlockRailBase.isRailBlock(this.world, new BlockPos(x, y - 1, z))) y--;
+        return new BlockPos(x, y, z);
+    }
+
+    protected double getMaxSpeed()
+    {
+        if (!canUseRail()) return getMaximumSpeed();
+        BlockPos pos = this.getCurrentRailPosition();
+        IBlockState state = this.world.getBlockState(pos);
+        if (!BlockRailBase.isRailBlock(state)) return getMaximumSpeed();
+
+        float railMaxSpeed = ((BlockRailBase)state.getBlock()).getRailMaxSpeed(world, this, pos);
+        return Math.min(railMaxSpeed, getCurrentCartSpeedCapOnRail());
+    }
+
+    /**
+     * Moved to allow overrides.
+     * This code handles minecart movement and speed capping when on a rail.
+     */
+    public void moveMinecartOnRail(BlockPos pos)
+    {
+        double mX = this.motionX;
+        double mZ = this.motionZ;
+
+        if (this.isBeingRidden())
+        {
+            mX *= 0.75D;
+            mZ *= 0.75D;
+        }
+
+        double max = this.getMaxSpeed();
+        mX = MathHelper.clamp(mX, -max, max);
+        mZ = MathHelper.clamp(mZ, -max, max);
+        this.move(MoverType.SELF, mX, 0.0D, mZ);
+    }
+
+    /**
+     * Gets the current global Minecart Collision handler if none
+     * is registered, returns null
+     * @return The collision handler or null
+     */
+    @Nullable
+    public static net.minecraftforge.common.IMinecartCollisionHandler getCollisionHandler()
+    {
+        return collisionHandler;
+    }
+
+    /**
+     * Sets the global Minecart Collision handler, overwrites any
+     * that is currently set.
+     * @param handler The new handler
+     */
+    public static void setCollisionHandler(net.minecraftforge.common.IMinecartCollisionHandler handler)
+    {
+        collisionHandler = handler;
+    }
+
+    /**
+     * This function returns an ItemStack that represents this cart.
+     * This should be an ItemStack that can be used by the player to place the cart,
+     * but is not necessary the item the cart drops when destroyed.
+     * @return An ItemStack that can be used to place the cart.
+     */
+    public ItemStack getCartItem()
+    {
+        if (this instanceof EntityMinecartFurnace)
+        {
+            return new ItemStack(Items.FURNACE_MINECART);
+        }
+        else if (this instanceof EntityMinecartChest)
+        {
+            return new ItemStack(Items.CHEST_MINECART);
+        }
+        else if (this instanceof EntityMinecartTNT)
+        {
+            return new ItemStack(Items.TNT_MINECART);
+        }
+        else if (this instanceof EntityMinecartHopper)
+        {
+            return new ItemStack(Items.HOPPER_MINECART);
+        }
+        else if (this instanceof EntityMinecartCommandBlock)
+        {
+            return new ItemStack(Items.COMMAND_BLOCK_MINECART);
+        }
+        return new ItemStack(Items.MINECART);
+    }
+
+    /**
+     * Returns true if this cart can currently use rails.
+     * This function is mainly used to gracefully detach a minecart from a rail.
+     * @return True if the minecart can use rails.
+     */
+    public boolean canUseRail()
+    {
+        return canUseRail;
+    }
+
+    /**
+     * Set whether the minecart can use rails.
+     * This function is mainly used to gracefully detach a minecart from a rail.
+     * @param use Whether the minecart can currently use rails.
+     */
+    public void setCanUseRail(boolean use)
+    {
+        canUseRail = use;
+    }
+
+    /**
+     * Return false if this cart should not call onMinecartPass() and should ignore Powered Rails.
+     * @return True if this cart should call onMinecartPass().
+     */
+    public boolean shouldDoRailFunctions()
+    {
+        return true;
+    }
+
+    /**
+     * Returns true if this cart is self propelled.
+     * @return True if powered.
+     */
+    public boolean isPoweredCart()
+    {
+        return getType() == EntityMinecart.Type.FURNACE;
+    }
+
+    /**
+     * Returns true if this cart can be ridden by an Entity.
+     * @return True if this cart can be ridden.
+     */
+    public boolean canBeRidden()
+    {
+        return this.getType() == EntityMinecart.Type.RIDEABLE;
+    }
+
+    /**
+     * Getters/setters for physics variables
+     */
+
+    /**
+     * Returns the carts max speed when traveling on rails. Carts going faster
+     * than 1.1 cause issues with chunk loading. Carts cant traverse slopes or
+     * corners at greater than 0.5 - 0.6. This value is compared with the rails
+     * max speed and the carts current speed cap to determine the carts current
+     * max speed. A normal rail's max speed is 0.4.
+     *
+     * @return Carts max speed.
+     */
+    public float getMaxCartSpeedOnRail()
+    {
+        return 1.2f;
+    }
+
+    /**
+     * Returns the current speed cap for the cart when traveling on rails. This
+     * functions differs from getMaxCartSpeedOnRail() in that it controls
+     * current movement and cannot be overridden. The value however can never be
+     * higher than getMaxCartSpeedOnRail().
+     *
+     * @return
+     */
+    public final float getCurrentCartSpeedCapOnRail()
+    {
+        return currentSpeedRail;
+    }
+
+    public final void setCurrentCartSpeedCapOnRail(float value)
+    {
+        value = Math.min(value, getMaxCartSpeedOnRail());
+        currentSpeedRail = value;
+    }
+
+    public float getMaxSpeedAirLateral()
+    {
+        return maxSpeedAirLateral;
+    }
+
+    public void setMaxSpeedAirLateral(float value)
+    {
+        maxSpeedAirLateral = value;
+    }
+
+    public float getMaxSpeedAirVertical()
+    {
+        return maxSpeedAirVertical;
+    }
+
+    public void setMaxSpeedAirVertical(float value)
+    {
+        maxSpeedAirVertical = value;
+    }
+
+    public double getDragAir()
+    {
+        return dragAir;
+    }
+
+    public void setDragAir(double value)
+    {
+        dragAir = value;
+    }
+
+    public double getSlopeAdjustment()
+    {
+        return 0.0078125D;
+    }
+
+    /**
+     * Called from Detector Rails to retrieve a redstone power level for comparators.
+     */
+    public int getComparatorLevel()
+    {
+        return -1;
+    }
+
+    /* =================================== FORGE END ===========================================*/
 
     public static enum Type
     {
