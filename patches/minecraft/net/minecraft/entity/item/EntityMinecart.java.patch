--- before/net/minecraft/entity/item/EntityMinecart.java
+++ after/net/minecraft/entity/item/EntityMinecart.java
@@ -38,26 +38,14 @@
 
 public abstract class EntityMinecart extends Entity implements IWorldNameable
 {
-    private static final DataParameter<Integer> ROLLING_AMPLITUDE = EntityDataManager.createKey(EntityMinecart.class, DataSerializers.VARINT);
-    private static final DataParameter<Integer> ROLLING_DIRECTION = EntityDataManager.createKey(EntityMinecart.class, DataSerializers.VARINT);
-    private static final DataParameter<Float> DAMAGE = EntityDataManager.createKey(EntityMinecart.class, DataSerializers.FLOAT);
-    private static final DataParameter<Integer> DISPLAY_TILE = EntityDataManager.createKey(EntityMinecart.class, DataSerializers.VARINT);
-    private static final DataParameter<Integer> DISPLAY_TILE_OFFSET = EntityDataManager.createKey(EntityMinecart.class, DataSerializers.VARINT);
-    private static final DataParameter<Boolean> SHOW_BLOCK = EntityDataManager.createKey(EntityMinecart.class, DataSerializers.BOOLEAN);
+    private static final DataParameter<Integer> ROLLING_AMPLITUDE = EntityDataManager.<Integer>createKey(EntityMinecart.class, DataSerializers.VARINT);
+    private static final DataParameter<Integer> ROLLING_DIRECTION = EntityDataManager.<Integer>createKey(EntityMinecart.class, DataSerializers.VARINT);
+    private static final DataParameter<Float> DAMAGE = EntityDataManager.<Float>createKey(EntityMinecart.class, DataSerializers.FLOAT);
+    private static final DataParameter<Integer> DISPLAY_TILE = EntityDataManager.<Integer>createKey(EntityMinecart.class, DataSerializers.VARINT);
+    private static final DataParameter<Integer> DISPLAY_TILE_OFFSET = EntityDataManager.<Integer>createKey(EntityMinecart.class, DataSerializers.VARINT);
+    private static final DataParameter<Boolean> SHOW_BLOCK = EntityDataManager.<Boolean>createKey(EntityMinecart.class, DataSerializers.BOOLEAN);
     private boolean isInReverse;
-    private static final int[][][] MATRIX = new int[][][]
-    {
-        {{0, 0, -1}, {0, 0, 1}},
-        {{ -1, 0, 0}, {1, 0, 0}},
-        {{ -1, -1, 0}, {1, 0, 0}},
-        {{ -1, 0, 0}, {1, -1, 0}},
-        {{0, 0, -1}, {0, -1, 1}},
-        {{0, -1, -1}, {0, 0, 1}},
-        {{0, 0, 1}, {1, 0, 0}},
-        {{0, 0, 1}, { -1, 0, 0}},
-        {{0, 0, -1}, { -1, 0, 0}},
-        {{0, 0, -1}, {1, 0, 0}}
-    };
+    private static final int[][][] MATRIX = new int[][][] {{{0, 0, -1}, {0, 0, 1}}, {{ -1, 0, 0}, {1, 0, 0}}, {{ -1, -1, 0}, {1, 0, 0}}, {{ -1, 0, 0}, {1, -1, 0}}, {{0, 0, -1}, {0, -1, 1}}, {{0, -1, -1}, {0, 0, 1}}, {{0, 0, 1}, {1, 0, 0}}, {{0, 0, 1}, { -1, 0, 0}}, {{0, 0, -1}, { -1, 0, 0}}, {{0, 0, -1}, {1, 0, 0}}};
     private int turnProgress;
     private double minecartX;
     private double minecartY;
@@ -71,6 +59,20 @@
     @SideOnly(Side.CLIENT)
     private double velocityZ;
 
+    /* Forge: Minecart Compatibility Layer Integration. */
+    public static float defaultMaxSpeedAirLateral = 0.4f;
+    public static float defaultMaxSpeedAirVertical = -1f;
+    public static double defaultDragAir = 0.94999998807907104D;
+    protected boolean canUseRail = true;
+    protected boolean canBePushed = true;
+    private static net.minecraftforge.common.IMinecartCollisionHandler collisionHandler = null;
+
+    /* Instance versions of the above physics properties */
+    private float currentSpeedRail = getMaxCartSpeedOnRail();
+    protected float maxSpeedAirLateral = defaultMaxSpeedAirLateral;
+    protected float maxSpeedAirVertical = defaultMaxSpeedAirVertical;
+    protected double dragAir = defaultDragAir;
+
     public EntityMinecart(World worldIn)
     {
         super(worldIn);
@@ -99,94 +101,92 @@
         }
     }
 
-    @Override
     protected boolean canTriggerWalking()
     {
         return false;
     }
 
-    @Override
     protected void entityInit()
     {
-        this.dataManager.register(ROLLING_AMPLITUDE, 0);
-        this.dataManager.register(ROLLING_DIRECTION, 1);
-        this.dataManager.register(DAMAGE, 0.0F);
-        this.dataManager.register(DISPLAY_TILE, 0);
-        this.dataManager.register(DISPLAY_TILE_OFFSET, 6);
-        this.dataManager.register(SHOW_BLOCK, false);
+        this.dataManager.register(ROLLING_AMPLITUDE, Integer.valueOf(0));
+        this.dataManager.register(ROLLING_DIRECTION, Integer.valueOf(1));
+        this.dataManager.register(DAMAGE, Float.valueOf(0.0F));
+        this.dataManager.register(DISPLAY_TILE, Integer.valueOf(0));
+        this.dataManager.register(DISPLAY_TILE_OFFSET, Integer.valueOf(6));
+        this.dataManager.register(SHOW_BLOCK, Boolean.valueOf(false));
     }
 
     @Nullable
-    @Override
     public AxisAlignedBB getCollisionBox(Entity entityIn)
     {
+        if (getCollisionHandler() != null) return getCollisionHandler().getCollisionBox(this, entityIn);
         return entityIn.canBePushed() ? entityIn.getEntityBoundingBox() : null;
     }
 
     @Nullable
-    @Override
     public AxisAlignedBB getCollisionBoundingBox()
     {
+        if (getCollisionHandler() != null) return getCollisionHandler().getBoundingBox(this);
         return null;
     }
 
-    @Override
     public boolean canBePushed()
     {
-        return true;
+        return canBePushed;
     }
 
     public EntityMinecart(World worldIn, double x, double y, double z)
     {
         this(worldIn);
         this.setPosition(x, y, z);
-        this.motionX = 0.0;
-        this.motionY = 0.0;
-        this.motionZ = 0.0;
+        this.motionX = 0.0D;
+        this.motionY = 0.0D;
+        this.motionZ = 0.0D;
         this.prevPosX = x;
         this.prevPosY = y;
         this.prevPosZ = z;
     }
 
-    @Override
     public double getMountedYOffset()
     {
-        return 0.0;
+        return 0.0D;
     }
 
-    @Override
     public boolean attackEntityFrom(DamageSource source, float amount)
     {
-        if (this.world.isRemote || this.isDead)
-        {
-            return true;
-        }
-        else if (this.isEntityInvulnerable(source))
-        {
-            return false;
+        if (!this.world.isRemote && !this.isDead)
+        {
+            if (this.isEntityInvulnerable(source))
+            {
+                return false;
+            }
+            else
+            {
+                this.setRollingDirection(-this.getRollingDirection());
+                this.setRollingAmplitude(10);
+                this.markVelocityChanged();
+                this.setDamage(this.getDamage() + amount * 10.0F);
+                boolean flag = source.getTrueSource() instanceof EntityPlayer && ((EntityPlayer)source.getTrueSource()).capabilities.isCreativeMode;
+
+                if (flag || this.getDamage() > 40.0F)
+                {
+                    this.removePassengers();
+
+                    if (flag && !this.hasCustomName())
+                    {
+                        this.setDead();
+                    }
+                    else
+                    {
+                        this.killMinecart(source);
+                    }
+                }
+
+                return true;
+            }
         }
         else
         {
-            this.setRollingDirection(-this.getRollingDirection());
-            this.setRollingAmplitude(10);
-            this.markVelocityChanged();
-            this.setDamage(this.getDamage() + amount * 10.0F);
-            boolean flag = source.getTrueSource() instanceof EntityPlayer && ((EntityPlayer)source.getTrueSource()).capabilities.isCreativeMode;
-
-            if (flag || this.getDamage() > 40.0F)
-            {
-                this.removePassengers();
-
-                if (flag && !this.hasCustomName())
-                {
-                    this.setDead();
-                }
-                else
-                {
-                    this.killMinecart(source);
-                }
-            }
-
             return true;
         }
     }
@@ -209,7 +209,6 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public void performHurtAnimation()
     {
         this.setRollingDirection(-this.getRollingDirection());
@@ -217,19 +216,16 @@
         this.setDamage(this.getDamage() + this.getDamage() * 10.0F);
     }
 
-    @Override
     public boolean canBeCollidedWith()
     {
         return !this.isDead;
     }
 
-    @Override
     public EnumFacing getAdjustedHorizontalFacing()
     {
         return this.isInReverse ? this.getHorizontalFacing().getOpposite().rotateY() : this.getHorizontalFacing().rotateY();
     }
 
-    @Override
     public void onUpdate()
     {
         if (this.getRollingAmplitude() > 0)
@@ -242,7 +238,7 @@
             this.setDamage(this.getDamage() - 1.0F);
         }
 
-        if (this.posY < -64.0)
+        if (this.posY < -64.0D)
         {
             this.outOfWorld();
         }
@@ -293,7 +289,7 @@
 
             if (this.timeUntilPortal > 0)
             {
-                this.timeUntilPortal--;
+                --this.timeUntilPortal;
             }
 
             this.world.profiler.endSection();
@@ -309,7 +305,7 @@
                 double d1 = MathHelper.wrapDegrees(this.minecartYaw - (double)this.rotationYaw);
                 this.rotationYaw = (float)((double)this.rotationYaw + d1 / (double)this.turnProgress);
                 this.rotationPitch = (float)((double)this.rotationPitch + (this.minecartPitch - (double)this.rotationPitch) / (double)this.turnProgress);
-                this.turnProgress--;
+                --this.turnProgress;
                 this.setPosition(d4, d5, d6);
                 this.setRotation(this.rotationYaw, this.rotationPitch);
             }
@@ -327,7 +323,7 @@
 
             if (!this.hasNoGravity())
             {
-                this.motionY -= 0.04F;
+                this.motionY -= 0.03999999910593033D;
             }
 
             int k = MathHelper.floor(this.posX);
@@ -336,19 +332,19 @@
 
             if (BlockRailBase.isRailBlock(this.world, new BlockPos(k, l - 1, i1)))
             {
-                l--;
+                --l;
             }
 
             BlockPos blockpos = new BlockPos(k, l, i1);
             IBlockState iblockstate = this.world.getBlockState(blockpos);
 
-            if (BlockRailBase.isRailBlock(iblockstate))
+            if (canUseRail() && BlockRailBase.isRailBlock(iblockstate))
             {
                 this.moveAlongTrack(blockpos, iblockstate);
 
                 if (iblockstate.getBlock() == Blocks.ACTIVATOR_RAIL)
                 {
-                    this.onActivatorRailPass(k, l, i1, iblockstate.getValue(BlockRailPowered.POWERED));
+                    this.onActivatorRailPass(k, l, i1, ((Boolean)iblockstate.getValue(BlockRailPowered.POWERED)).booleanValue());
                 }
             }
             else
@@ -361,9 +357,9 @@
             double d0 = this.prevPosX - this.posX;
             double d2 = this.prevPosZ - this.posZ;
 
-            if (d0 * d0 + d2 * d2 > 0.001)
+            if (d0 * d0 + d2 * d2 > 0.001D)
             {
-                this.rotationYaw = (float)(MathHelper.atan2(d2, d0) * 180.0 / Math.PI);
+                this.rotationYaw = (float)(MathHelper.atan2(d2, d0) * 180.0D / Math.PI);
 
                 if (this.isInReverse)
                 {
@@ -373,7 +369,7 @@
 
             double d3 = (double)MathHelper.wrapDegrees(this.rotationYaw - this.prevRotationYaw);
 
-            if (d3 < -170.0 || d3 >= 170.0)
+            if (d3 < -170.0D || d3 >= 170.0D)
             {
                 this.rotationYaw += 180.0F;
                 this.isInReverse = !this.isInReverse;
@@ -381,22 +377,21 @@
 
             this.setRotation(this.rotationYaw, this.rotationPitch);
 
-            if (this.getType() == EntityMinecart.Type.RIDEABLE && this.motionX * this.motionX + this.motionZ * this.motionZ > 0.01)
+            AxisAlignedBB box;
+            if (getCollisionHandler() != null) box = getCollisionHandler().getMinecartCollisionBox(this);
+            else                               box = this.getEntityBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D);
+
+            if (canBeRidden() && this.motionX * this.motionX + this.motionZ * this.motionZ > 0.01D)
             {
-                List<Entity> list = this.world
-                                    .getEntitiesInAABBexcluding(this, this.getEntityBoundingBox().grow(0.2F, 0.0, 0.2F), EntitySelectors.getTeamCollisionPredicate(this));
+                List<Entity> list = this.world.getEntitiesInAABBexcluding(this, box, EntitySelectors.getTeamCollisionPredicate(this));
 
                 if (!list.isEmpty())
                 {
-                    for (int j1 = 0; j1 < list.size(); j1++)
+                    for (int j1 = 0; j1 < list.size(); ++j1)
                     {
                         Entity entity1 = list.get(j1);
 
-                        if (!(entity1 instanceof EntityPlayer)
-                                && !(entity1 instanceof EntityIronGolem)
-                                && !(entity1 instanceof EntityMinecart)
-                                && !this.isBeingRidden()
-                                && !entity1.isRiding())
+                        if (!(entity1 instanceof EntityPlayer) && !(entity1 instanceof EntityIronGolem) && !(entity1 instanceof EntityMinecart) && !this.isBeingRidden() && !entity1.isRiding())
                         {
                             entity1.startRiding(this);
                         }
@@ -409,7 +404,7 @@
             }
             else
             {
-                for (Entity entity : this.world.getEntitiesWithinAABBExcludingEntity(this, this.getEntityBoundingBox().grow(0.2F, 0.0, 0.2F)))
+                for (Entity entity : this.world.getEntitiesWithinAABBExcludingEntity(this, box))
                 {
                     if (!this.isPassenger(entity) && entity.canBePushed() && entity instanceof EntityMinecart)
                     {
@@ -419,12 +414,13 @@
             }
 
             this.handleWaterMovement();
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.minecart.MinecartUpdateEvent(this, this.getCurrentRailPosition()));
         }
     }
 
     protected double getMaximumSpeed()
     {
-        return 0.4;
+        return 0.4D;
     }
 
     public void onActivatorRailPass(int x, int y, int z, boolean receivingPower)
@@ -433,24 +429,35 @@
 
     protected void moveDerailedMinecart()
     {
-        double d0 = this.getMaximumSpeed();
+        double d0 = onGround ? this.getMaximumSpeed() : getMaxSpeedAirLateral();
         this.motionX = MathHelper.clamp(this.motionX, -d0, d0);
         this.motionZ = MathHelper.clamp(this.motionZ, -d0, d0);
 
+        double moveY = motionY;
+        if(getMaxSpeedAirVertical() > 0 && motionY > getMaxSpeedAirVertical())
+        {
+            moveY = getMaxSpeedAirVertical();
+            if(Math.abs(motionX) < 0.3f && Math.abs(motionZ) < 0.3f)
+            {
+                moveY = 0.15f;
+                motionY = moveY;
+            }
+        }
+
         if (this.onGround)
         {
-            this.motionX *= 0.5;
-            this.motionY *= 0.5;
-            this.motionZ *= 0.5;
+            this.motionX *= 0.5D;
+            this.motionY *= 0.5D;
+            this.motionZ *= 0.5D;
         }
 
-        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+        this.move(MoverType.SELF, this.motionX, moveY, this.motionZ);
 
         if (!this.onGround)
         {
-            this.motionX *= 0.95F;
-            this.motionY *= 0.95F;
-            this.motionZ *= 0.95F;
+            this.motionX *= getDragAir();
+            this.motionY *= getDragAir();
+            this.motionZ *= getDragAir();
         }
     }
 
@@ -466,30 +473,30 @@
 
         if (blockrailbase == Blocks.GOLDEN_RAIL)
         {
-            flag = state.getValue(BlockRailPowered.POWERED);
+            flag = ((Boolean)state.getValue(BlockRailPowered.POWERED)).booleanValue();
             flag1 = !flag;
         }
 
-        double d0 = 0.0078125;
-        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = state.getValue(blockrailbase.getShapeProperty());
+        double slopeAdjustment = getSlopeAdjustment();
+        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = blockrailbase.getRailDirection(world, pos, state, this);
 
         switch (blockrailbase$enumraildirection)
         {
             case ASCENDING_EAST:
-                this.motionX -= 0.0078125;
-                this.posY++;
+                this.motionX -= slopeAdjustment;
+                ++this.posY;
                 break;
             case ASCENDING_WEST:
-                this.motionX += 0.0078125;
-                this.posY++;
+                this.motionX += slopeAdjustment;
+                ++this.posY;
                 break;
             case ASCENDING_NORTH:
-                this.motionZ += 0.0078125;
-                this.posY++;
+                this.motionZ += slopeAdjustment;
+                ++this.posY;
                 break;
             case ASCENDING_SOUTH:
-                this.motionZ -= 0.0078125;
-                this.posY++;
+                this.motionZ -= slopeAdjustment;
+                ++this.posY;
         }
 
         int[][] aint = MATRIX[blockrailbase$enumraildirection.getMetadata()];
@@ -498,7 +505,7 @@
         double d3 = Math.sqrt(d1 * d1 + d2 * d2);
         double d4 = this.motionX * d1 + this.motionZ * d2;
 
-        if (d4 < 0.0)
+        if (d4 < 0.0D)
         {
             d1 = -d1;
             d2 = -d2;
@@ -506,103 +513,87 @@
 
         double d5 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 
-        if (d5 > 2.0)
+        if (d5 > 2.0D)
         {
-            d5 = 2.0;
+            d5 = 2.0D;
         }
 
         this.motionX = d5 * d1 / d3;
         this.motionZ = d5 * d2 / d3;
-        Entity entity = this.getPassengers().isEmpty() ? null : this.getPassengers().get(0);
+        Entity entity = this.getPassengers().isEmpty() ? null : (Entity)this.getPassengers().get(0);
 
         if (entity instanceof EntityLivingBase)
         {
             double d6 = (double)((EntityLivingBase)entity).moveForward;
 
-            if (d6 > 0.0)
+            if (d6 > 0.0D)
             {
-                double d7 = -Math.sin((double)(entity.rotationYaw * (float)(Math.PI / 180.0)));
-                double d8 = Math.cos((double)(entity.rotationYaw * (float)(Math.PI / 180.0)));
+                double d7 = -Math.sin((double)(entity.rotationYaw * 0.017453292F));
+                double d8 = Math.cos((double)(entity.rotationYaw * 0.017453292F));
                 double d9 = this.motionX * this.motionX + this.motionZ * this.motionZ;
 
-                if (d9 < 0.01)
+                if (d9 < 0.01D)
                 {
-                    this.motionX += d7 * 0.1;
-                    this.motionZ += d8 * 0.1;
+                    this.motionX += d7 * 0.1D;
+                    this.motionZ += d8 * 0.1D;
                     flag1 = false;
                 }
             }
         }
 
-        if (flag1)
+        if (flag1 && shouldDoRailFunctions())
         {
             double d17 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 
-            if (d17 < 0.03)
+            if (d17 < 0.03D)
             {
-                this.motionX *= 0.0;
-                this.motionY *= 0.0;
-                this.motionZ *= 0.0;
+                this.motionX *= 0.0D;
+                this.motionY *= 0.0D;
+                this.motionZ *= 0.0D;
             }
             else
             {
-                this.motionX *= 0.5;
-                this.motionY *= 0.0;
-                this.motionZ *= 0.5;
+                this.motionX *= 0.5D;
+                this.motionY *= 0.0D;
+                this.motionZ *= 0.5D;
             }
         }
 
-        double d18 = (double)pos.getX() + 0.5 + (double)aint[0][0] * 0.5;
-        double d19 = (double)pos.getZ() + 0.5 + (double)aint[0][2] * 0.5;
-        double d20 = (double)pos.getX() + 0.5 + (double)aint[1][0] * 0.5;
-        double d21 = (double)pos.getZ() + 0.5 + (double)aint[1][2] * 0.5;
+        double d18 = (double)pos.getX() + 0.5D + (double)aint[0][0] * 0.5D;
+        double d19 = (double)pos.getZ() + 0.5D + (double)aint[0][2] * 0.5D;
+        double d20 = (double)pos.getX() + 0.5D + (double)aint[1][0] * 0.5D;
+        double d21 = (double)pos.getZ() + 0.5D + (double)aint[1][2] * 0.5D;
         d1 = d20 - d18;
         d2 = d21 - d19;
         double d10;
 
-        if (d1 == 0.0)
+        if (d1 == 0.0D)
         {
-            this.posX = (double)pos.getX() + 0.5;
+            this.posX = (double)pos.getX() + 0.5D;
             d10 = this.posZ - (double)pos.getZ();
         }
-        else if (d2 == 0.0)
+        else if (d2 == 0.0D)
         {
-            this.posZ = (double)pos.getZ() + 0.5;
+            this.posZ = (double)pos.getZ() + 0.5D;
             d10 = this.posX - (double)pos.getX();
         }
         else
         {
             double d11 = this.posX - d18;
             double d12 = this.posZ - d19;
-            d10 = (d11 * d1 + d12 * d2) * 2.0;
+            d10 = (d11 * d1 + d12 * d2) * 2.0D;
         }
 
         this.posX = d18 + d1 * d10;
         this.posZ = d19 + d2 * d10;
         this.setPosition(this.posX, this.posY, this.posZ);
-        double d22 = this.motionX;
-        double d23 = this.motionZ;
-
-        if (this.isBeingRidden())
-        {
-            d22 *= 0.75;
-            d23 *= 0.75;
-        }
-
-        double d13 = this.getMaximumSpeed();
-        d22 = MathHelper.clamp(d22, -d13, d13);
-        d23 = MathHelper.clamp(d23, -d13, d13);
-        this.move(MoverType.SELF, d22, 0.0, d23);
-
-        if (aint[0][1] != 0
-                && MathHelper.floor(this.posX) - pos.getX() == aint[0][0]
-                && MathHelper.floor(this.posZ) - pos.getZ() == aint[0][2])
+        this.moveMinecartOnRail(pos);
+
+        if (aint[0][1] != 0 && MathHelper.floor(this.posX) - pos.getX() == aint[0][0] && MathHelper.floor(this.posZ) - pos.getZ() == aint[0][2])
         {
             this.setPosition(this.posX, this.posY + (double)aint[0][1], this.posZ);
         }
-        else if (aint[1][1] != 0
-                 && MathHelper.floor(this.posX) - pos.getX() == aint[1][0]
-                 && MathHelper.floor(this.posZ) - pos.getZ() == aint[1][2])
+        else if (aint[1][1] != 0 && MathHelper.floor(this.posX) - pos.getX() == aint[1][0] && MathHelper.floor(this.posZ) - pos.getZ() == aint[1][2])
         {
             this.setPosition(this.posX, this.posY + (double)aint[1][1], this.posZ);
         }
@@ -612,10 +603,10 @@
 
         if (vec3d1 != null && vec3d != null)
         {
-            double d14 = (vec3d.y - vec3d1.y) * 0.05;
+            double d14 = (vec3d.y - vec3d1.y) * 0.05D;
             d5 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 
-            if (d5 > 0.0)
+            if (d5 > 0.0D)
             {
                 this.motionX = this.motionX / d5 * (d5 + d14);
                 this.motionZ = this.motionZ / d5 * (d5 + d14);
@@ -634,36 +625,42 @@
             this.motionZ = d5 * (double)(i - pos.getZ());
         }
 
-        if (flag)
+
+        if(shouldDoRailFunctions())
+        {
+            ((BlockRailBase)state.getBlock()).onMinecartPass(world, this, pos);
+        }
+
+        if (flag && shouldDoRailFunctions())
         {
             double d15 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 
-            if (d15 > 0.01)
+            if (d15 > 0.01D)
             {
-                double d16 = 0.06;
-                this.motionX = this.motionX + this.motionX / d15 * 0.06;
-                this.motionZ = this.motionZ + this.motionZ / d15 * 0.06;
+                double d16 = 0.06D;
+                this.motionX += this.motionX / d15 * 0.06D;
+                this.motionZ += this.motionZ / d15 * 0.06D;
             }
             else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.EAST_WEST)
             {
                 if (this.world.getBlockState(pos.west()).isNormalCube())
                 {
-                    this.motionX = 0.02;
+                    this.motionX = 0.02D;
                 }
                 else if (this.world.getBlockState(pos.east()).isNormalCube())
                 {
-                    this.motionX = -0.02;
+                    this.motionX = -0.02D;
                 }
             }
             else if (blockrailbase$enumraildirection == BlockRailBase.EnumRailDirection.NORTH_SOUTH)
             {
                 if (this.world.getBlockState(pos.north()).isNormalCube())
                 {
-                    this.motionZ = 0.02;
+                    this.motionZ = 0.02D;
                 }
                 else if (this.world.getBlockState(pos.south()).isNormalCube())
                 {
-                    this.motionZ = -0.02;
+                    this.motionZ = -0.02D;
                 }
             }
         }
@@ -673,19 +670,18 @@
     {
         if (this.isBeingRidden())
         {
-            this.motionX *= 0.997F;
-            this.motionY *= 0.0;
-            this.motionZ *= 0.997F;
+            this.motionX *= 0.996999979019165D;
+            this.motionY *= 0.0D;
+            this.motionZ *= 0.996999979019165D;
         }
         else
         {
-            this.motionX *= 0.96F;
-            this.motionY *= 0.0;
-            this.motionZ *= 0.96F;
+            this.motionX *= 0.9599999785423279D;
+            this.motionY *= 0.0D;
+            this.motionZ *= 0.9599999785423279D;
         }
     }
 
-    @Override
     public void setPosition(double x, double y, double z)
     {
         this.posX = x;
@@ -693,9 +689,7 @@
         this.posZ = z;
         float f = this.width / 2.0F;
         float f1 = this.height;
-        this.setEntityBoundingBox(
-            new AxisAlignedBB(x - (double)f, y, z - (double)f, x + (double)f, y + (double)f1, z + (double)f)
-        );
+        this.setEntityBoundingBox(new AxisAlignedBB(x - (double)f, y, z - (double)f, x + (double)f, y + (double)f1, z + (double)f));
     }
 
     @Nullable
@@ -708,16 +702,14 @@
 
         if (BlockRailBase.isRailBlock(this.world, new BlockPos(i, j - 1, k)))
         {
-            j--;
+            --j;
         }
 
         IBlockState iblockstate = this.world.getBlockState(new BlockPos(i, j, k));
 
         if (BlockRailBase.isRailBlock(iblockstate))
         {
-            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = iblockstate.getValue(
-                        ((BlockRailBase)iblockstate.getBlock()).getShapeProperty()
-                    );
+            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = ((BlockRailBase)iblockstate.getBlock()).getRailDirection(world, new BlockPos(i, j, k), iblockstate, this);
             y = (double)j;
 
             if (blockrailbase$enumraildirection.isAscending())
@@ -729,10 +721,10 @@
             double d0 = (double)(aint[1][0] - aint[0][0]);
             double d1 = (double)(aint[1][2] - aint[0][2]);
             double d2 = Math.sqrt(d0 * d0 + d1 * d1);
-            d0 /= d2;
-            d1 /= d2;
-            x += d0 * offset;
-            z += d1 * offset;
+            d0 = d0 / d2;
+            d1 = d1 / d2;
+            x = x + d0 * offset;
+            z = z + d1 * offset;
 
             if (aint[0][1] != 0 && MathHelper.floor(x) - i == aint[0][0] && MathHelper.floor(z) - k == aint[0][2])
             {
@@ -760,33 +752,31 @@
 
         if (BlockRailBase.isRailBlock(this.world, new BlockPos(i, j - 1, k)))
         {
-            j--;
+            --j;
         }
 
         IBlockState iblockstate = this.world.getBlockState(new BlockPos(i, j, k));
 
         if (BlockRailBase.isRailBlock(iblockstate))
         {
-            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = iblockstate.getValue(
-                        ((BlockRailBase)iblockstate.getBlock()).getShapeProperty()
-                    );
+            BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = ((BlockRailBase)iblockstate.getBlock()).getRailDirection(world, new BlockPos(i, j, k), iblockstate, this);
             int[][] aint = MATRIX[blockrailbase$enumraildirection.getMetadata()];
-            double d0 = (double)i + 0.5 + (double)aint[0][0] * 0.5;
-            double d1 = (double)j + 0.0625 + (double)aint[0][1] * 0.5;
-            double d2 = (double)k + 0.5 + (double)aint[0][2] * 0.5;
-            double d3 = (double)i + 0.5 + (double)aint[1][0] * 0.5;
-            double d4 = (double)j + 0.0625 + (double)aint[1][1] * 0.5;
-            double d5 = (double)k + 0.5 + (double)aint[1][2] * 0.5;
+            double d0 = (double)i + 0.5D + (double)aint[0][0] * 0.5D;
+            double d1 = (double)j + 0.0625D + (double)aint[0][1] * 0.5D;
+            double d2 = (double)k + 0.5D + (double)aint[0][2] * 0.5D;
+            double d3 = (double)i + 0.5D + (double)aint[1][0] * 0.5D;
+            double d4 = (double)j + 0.0625D + (double)aint[1][1] * 0.5D;
+            double d5 = (double)k + 0.5D + (double)aint[1][2] * 0.5D;
             double d6 = d3 - d0;
-            double d7 = (d4 - d1) * 2.0;
+            double d7 = (d4 - d1) * 2.0D;
             double d8 = d5 - d2;
             double d9;
 
-            if (d6 == 0.0)
+            if (d6 == 0.0D)
             {
                 d9 = p_70489_5_ - (double)k;
             }
-            else if (d8 == 0.0)
+            else if (d8 == 0.0D)
             {
                 d9 = p_70489_1_ - (double)i;
             }
@@ -794,21 +784,21 @@
             {
                 double d10 = p_70489_1_ - d0;
                 double d11 = p_70489_5_ - d2;
-                d9 = (d10 * d6 + d11 * d8) * 2.0;
+                d9 = (d10 * d6 + d11 * d8) * 2.0D;
             }
 
             p_70489_1_ = d0 + d6 * d9;
             p_70489_3_ = d1 + d7 * d9;
             p_70489_5_ = d2 + d8 * d9;
 
-            if (d7 < 0.0)
+            if (d7 < 0.0D)
             {
-                p_70489_3_++;
+                ++p_70489_3_;
             }
 
-            if (d7 > 0.0)
+            if (d7 > 0.0D)
             {
-                p_70489_3_ += 0.5;
+                p_70489_3_ += 0.5D;
             }
 
             return new Vec3d(p_70489_1_, p_70489_3_, p_70489_5_);
@@ -820,18 +810,16 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public AxisAlignedBB getRenderBoundingBox()
     {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
-        return this.hasDisplayTile() ? axisalignedbb.grow((double)Math.abs(this.getDisplayTileOffset()) / 16.0) : axisalignedbb;
+        return this.hasDisplayTile() ? axisalignedbb.grow((double)Math.abs(this.getDisplayTileOffset()) / 16.0D) : axisalignedbb;
     }
 
     public static void registerFixesMinecart(DataFixer fixer, Class<?> name)
     {
     }
 
-    @Override
     protected void readEntityFromNBT(NBTTagCompound compound)
     {
         if (compound.getBoolean("CustomDisplayTile"))
@@ -853,7 +841,6 @@
         }
     }
 
-    @Override
     protected void writeEntityToNBT(NBTTagCompound compound)
     {
         if (this.hasDisplayTile())
@@ -867,9 +854,14 @@
         }
     }
 
-    @Override
     public void applyEntityCollision(Entity entityIn)
     {
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.minecart.MinecartCollisionEvent(this, entityIn));
+        if (getCollisionHandler() != null)
+        {
+            getCollisionHandler().onEntityCollision(this, entityIn);
+            return;
+        }
         if (!this.world.isRemote)
         {
             if (!entityIn.noClip && !this.noClip)
@@ -880,41 +872,36 @@
                     double d1 = entityIn.posZ - this.posZ;
                     double d2 = d0 * d0 + d1 * d1;
 
-                    if (d2 >= 1.0E-4F)
+                    if (d2 >= 9.999999747378752E-5D)
                     {
                         d2 = (double)MathHelper.sqrt(d2);
-                        d0 /= d2;
-                        d1 /= d2;
-                        double d3 = 1.0 / d2;
+                        d0 = d0 / d2;
+                        d1 = d1 / d2;
+                        double d3 = 1.0D / d2;
 
-                        if (d3 > 1.0)
+                        if (d3 > 1.0D)
                         {
-                            d3 = 1.0;
+                            d3 = 1.0D;
                         }
 
-                        d0 *= d3;
-                        d1 *= d3;
-                        d0 *= 0.1F;
-                        d1 *= 0.1F;
-                        d0 *= (double)(1.0F - this.entityCollisionReduction);
-                        d1 *= (double)(1.0F - this.entityCollisionReduction);
-                        d0 *= 0.5;
-                        d1 *= 0.5;
+                        d0 = d0 * d3;
+                        d1 = d1 * d3;
+                        d0 = d0 * 0.10000000149011612D;
+                        d1 = d1 * 0.10000000149011612D;
+                        d0 = d0 * (double)(1.0F - this.entityCollisionReduction);
+                        d1 = d1 * (double)(1.0F - this.entityCollisionReduction);
+                        d0 = d0 * 0.5D;
+                        d1 = d1 * 0.5D;
 
                         if (entityIn instanceof EntityMinecart)
                         {
                             double d4 = entityIn.posX - this.posX;
                             double d5 = entityIn.posZ - this.posZ;
-                            Vec3d vec3d = new Vec3d(d4, 0.0, d5).normalize();
-                            Vec3d vec3d1 = new Vec3d(
-                                (double)MathHelper.cos(this.rotationYaw * (float)(Math.PI / 180.0)),
-                                0.0,
-                                (double)MathHelper.sin(this.rotationYaw * (float)(Math.PI / 180.0))
-                            )
-                            .normalize();
+                            Vec3d vec3d = (new Vec3d(d4, 0.0D, d5)).normalize();
+                            Vec3d vec3d1 = (new Vec3d((double)MathHelper.cos(this.rotationYaw * 0.017453292F), 0.0D, (double)MathHelper.sin(this.rotationYaw * 0.017453292F))).normalize();
                             double d6 = Math.abs(vec3d.dotProduct(vec3d1));
 
-                            if (d6 < 0.8F)
+                            if (d6 < 0.800000011920929D)
                             {
                                 return;
                             }
@@ -922,39 +909,38 @@
                             double d7 = entityIn.motionX + this.motionX;
                             double d8 = entityIn.motionZ + this.motionZ;
 
-                            if (((EntityMinecart)entityIn).getType() == EntityMinecart.Type.FURNACE && this.getType() != EntityMinecart.Type.FURNACE)
+                            if (((EntityMinecart)entityIn).isPoweredCart() && !isPoweredCart())
                             {
-                                this.motionX *= 0.2F;
-                                this.motionZ *= 0.2F;
-                                this.addVelocity(entityIn.motionX - d0, 0.0, entityIn.motionZ - d1);
-                                entityIn.motionX *= 0.95F;
-                                entityIn.motionZ *= 0.95F;
+                                this.motionX *= 0.20000000298023224D;
+                                this.motionZ *= 0.20000000298023224D;
+                                this.addVelocity(entityIn.motionX - d0, 0.0D, entityIn.motionZ - d1);
+                                entityIn.motionX *= 0.949999988079071D;
+                                entityIn.motionZ *= 0.949999988079071D;
                             }
-                            else if (((EntityMinecart)entityIn).getType() != EntityMinecart.Type.FURNACE
-                                     && this.getType() == EntityMinecart.Type.FURNACE)
+                            else if (!((EntityMinecart)entityIn).isPoweredCart() && isPoweredCart())
                             {
-                                entityIn.motionX *= 0.2F;
-                                entityIn.motionZ *= 0.2F;
-                                entityIn.addVelocity(this.motionX + d0, 0.0, this.motionZ + d1);
-                                this.motionX *= 0.95F;
-                                this.motionZ *= 0.95F;
+                                entityIn.motionX *= 0.20000000298023224D;
+                                entityIn.motionZ *= 0.20000000298023224D;
+                                entityIn.addVelocity(this.motionX + d0, 0.0D, this.motionZ + d1);
+                                this.motionX *= 0.949999988079071D;
+                                this.motionZ *= 0.949999988079071D;
                             }
                             else
                             {
-                                d7 /= 2.0;
-                                d8 /= 2.0;
-                                this.motionX *= 0.2F;
-                                this.motionZ *= 0.2F;
-                                this.addVelocity(d7 - d0, 0.0, d8 - d1);
-                                entityIn.motionX *= 0.2F;
-                                entityIn.motionZ *= 0.2F;
-                                entityIn.addVelocity(d7 + d0, 0.0, d8 + d1);
+                                d7 = d7 / 2.0D;
+                                d8 = d8 / 2.0D;
+                                this.motionX *= 0.20000000298023224D;
+                                this.motionZ *= 0.20000000298023224D;
+                                this.addVelocity(d7 - d0, 0.0D, d8 - d1);
+                                entityIn.motionX *= 0.20000000298023224D;
+                                entityIn.motionZ *= 0.20000000298023224D;
+                                entityIn.addVelocity(d7 + d0, 0.0D, d8 + d1);
                             }
                         }
                         else
                         {
-                            this.addVelocity(-d0, 0.0, -d1);
-                            entityIn.addVelocity(d0 / 4.0, 0.0, d1 / 4.0);
+                            this.addVelocity(-d0, 0.0D, -d1);
+                            entityIn.addVelocity(d0 / 4.0D, 0.0D, d1 / 4.0D);
                         }
                     }
                 }
@@ -963,10 +949,7 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
-    public void setPositionAndRotationDirect(
-        double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport
-    )
+    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
     {
         this.minecartX = x;
         this.minecartY = y;
@@ -979,8 +962,12 @@
         this.motionZ = this.velocityZ;
     }
 
+    public void setDamage(float damage)
+    {
+        this.dataManager.set(DAMAGE, Float.valueOf(damage));
+    }
+
     @SideOnly(Side.CLIENT)
-    @Override
     public void setVelocity(double x, double y, double z)
     {
         this.motionX = x;
@@ -991,41 +978,36 @@
         this.velocityZ = this.motionZ;
     }
 
-    public void setDamage(float damage)
-    {
-        this.dataManager.set(DAMAGE, damage);
-    }
-
     public float getDamage()
     {
-        return this.dataManager.get(DAMAGE);
+        return ((Float)this.dataManager.get(DAMAGE)).floatValue();
     }
 
     public void setRollingAmplitude(int rollingAmplitude)
     {
-        this.dataManager.set(ROLLING_AMPLITUDE, rollingAmplitude);
+        this.dataManager.set(ROLLING_AMPLITUDE, Integer.valueOf(rollingAmplitude));
     }
 
     public int getRollingAmplitude()
     {
-        return this.dataManager.get(ROLLING_AMPLITUDE);
+        return ((Integer)this.dataManager.get(ROLLING_AMPLITUDE)).intValue();
     }
 
     public void setRollingDirection(int rollingDirection)
     {
-        this.dataManager.set(ROLLING_DIRECTION, rollingDirection);
+        this.dataManager.set(ROLLING_DIRECTION, Integer.valueOf(rollingDirection));
     }
 
     public int getRollingDirection()
     {
-        return this.dataManager.get(ROLLING_DIRECTION);
+        return ((Integer)this.dataManager.get(ROLLING_DIRECTION)).intValue();
     }
 
     public abstract EntityMinecart.Type getType();
 
     public IBlockState getDisplayTile()
     {
-        return !this.hasDisplayTile() ? this.getDefaultDisplayTile() : Block.getStateById(this.getDataManager().get(DISPLAY_TILE));
+        return !this.hasDisplayTile() ? this.getDefaultDisplayTile() : Block.getStateById(((Integer)this.getDataManager().get(DISPLAY_TILE)).intValue());
     }
 
     public IBlockState getDefaultDisplayTile()
@@ -1035,7 +1017,7 @@
 
     public int getDisplayTileOffset()
     {
-        return !this.hasDisplayTile() ? this.getDefaultDisplayTileOffset() : this.getDataManager().get(DISPLAY_TILE_OFFSET);
+        return !this.hasDisplayTile() ? this.getDefaultDisplayTileOffset() : ((Integer)this.getDataManager().get(DISPLAY_TILE_OFFSET)).intValue();
     }
 
     public int getDefaultDisplayTileOffset()
@@ -1045,25 +1027,255 @@
 
     public void setDisplayTile(IBlockState displayTile)
     {
-        this.getDataManager().set(DISPLAY_TILE, Block.getStateId(displayTile));
+        this.getDataManager().set(DISPLAY_TILE, Integer.valueOf(Block.getStateId(displayTile)));
         this.setHasDisplayTile(true);
     }
 
     public void setDisplayTileOffset(int displayTileOffset)
     {
-        this.getDataManager().set(DISPLAY_TILE_OFFSET, displayTileOffset);
+        this.getDataManager().set(DISPLAY_TILE_OFFSET, Integer.valueOf(displayTileOffset));
         this.setHasDisplayTile(true);
     }
 
     public boolean hasDisplayTile()
     {
-        return this.getDataManager().get(SHOW_BLOCK);
+        return ((Boolean)this.getDataManager().get(SHOW_BLOCK)).booleanValue();
     }
 
     public void setHasDisplayTile(boolean showBlock)
     {
-        this.getDataManager().set(SHOW_BLOCK, showBlock);
-    }
+        this.getDataManager().set(SHOW_BLOCK, Boolean.valueOf(showBlock));
+    }
+    
+    @Override
+    public boolean processInitialInteract(EntityPlayer player, net.minecraft.util.EnumHand hand)
+    {
+        return net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.minecart.MinecartInteractEvent(this, player, hand));
+    }
+
+    /* =================================== FORGE START ===========================================*/
+    private BlockPos getCurrentRailPosition()
+    {
+        int x = MathHelper.floor(this.posX);
+        int y = MathHelper.floor(this.posY);
+        int z = MathHelper.floor(this.posZ);
+
+        if (BlockRailBase.isRailBlock(this.world, new BlockPos(x, y - 1, z))) y--;
+        return new BlockPos(x, y, z);
+    }
+
+    protected double getMaxSpeed()
+    {
+        if (!canUseRail()) return getMaximumSpeed();
+        BlockPos pos = this.getCurrentRailPosition();
+        IBlockState state = this.world.getBlockState(pos);
+        if (!BlockRailBase.isRailBlock(state)) return getMaximumSpeed();
+
+        float railMaxSpeed = ((BlockRailBase)state.getBlock()).getRailMaxSpeed(world, this, pos);
+        return Math.min(railMaxSpeed, getCurrentCartSpeedCapOnRail());
+    }
+
+    /**
+     * Moved to allow overrides.
+     * This code handles minecart movement and speed capping when on a rail.
+     */
+    public void moveMinecartOnRail(BlockPos pos)
+    {
+        double mX = this.motionX;
+        double mZ = this.motionZ;
+
+        if (this.isBeingRidden())
+        {
+            mX *= 0.75D;
+            mZ *= 0.75D;
+        }
+
+        double max = this.getMaxSpeed();
+        mX = MathHelper.clamp(mX, -max, max);
+        mZ = MathHelper.clamp(mZ, -max, max);
+        this.move(MoverType.SELF, mX, 0.0D, mZ);
+    }
+
+    /**
+     * Gets the current global Minecart Collision handler if none
+     * is registered, returns null
+     * @return The collision handler or null
+     */
+    @Nullable
+    public static net.minecraftforge.common.IMinecartCollisionHandler getCollisionHandler()
+    {
+        return collisionHandler;
+    }
+
+    /**
+     * Sets the global Minecart Collision handler, overwrites any
+     * that is currently set.
+     * @param handler The new handler
+     */
+    public static void setCollisionHandler(net.minecraftforge.common.IMinecartCollisionHandler handler)
+    {
+        collisionHandler = handler;
+    }
+
+    /**
+     * This function returns an ItemStack that represents this cart.
+     * This should be an ItemStack that can be used by the player to place the cart,
+     * but is not necessary the item the cart drops when destroyed.
+     * @return An ItemStack that can be used to place the cart.
+     */
+    public ItemStack getCartItem()
+    {
+        if (this instanceof EntityMinecartFurnace)
+        {
+            return new ItemStack(Items.FURNACE_MINECART);
+        }
+        else if (this instanceof EntityMinecartChest)
+        {
+            return new ItemStack(Items.CHEST_MINECART);
+        }
+        else if (this instanceof EntityMinecartTNT)
+        {
+            return new ItemStack(Items.TNT_MINECART);
+        }
+        else if (this instanceof EntityMinecartHopper)
+        {
+            return new ItemStack(Items.HOPPER_MINECART);
+        }
+        else if (this instanceof EntityMinecartCommandBlock)
+        {
+            return new ItemStack(Items.COMMAND_BLOCK_MINECART);
+        }
+        return new ItemStack(Items.MINECART);
+    }
+
+    /**
+     * Returns true if this cart can currently use rails.
+     * This function is mainly used to gracefully detach a minecart from a rail.
+     * @return True if the minecart can use rails.
+     */
+    public boolean canUseRail()
+    {
+        return canUseRail;
+    }
+
+    /**
+     * Set whether the minecart can use rails.
+     * This function is mainly used to gracefully detach a minecart from a rail.
+     * @param use Whether the minecart can currently use rails.
+     */
+    public void setCanUseRail(boolean use)
+    {
+        canUseRail = use;
+    }
+
+    /**
+     * Return false if this cart should not call onMinecartPass() and should ignore Powered Rails.
+     * @return True if this cart should call onMinecartPass().
+     */
+    public boolean shouldDoRailFunctions()
+    {
+        return true;
+    }
+
+    /**
+     * Returns true if this cart is self propelled.
+     * @return True if powered.
+     */
+    public boolean isPoweredCart()
+    {
+        return getType() == EntityMinecart.Type.FURNACE;
+    }
+
+    /**
+     * Returns true if this cart can be ridden by an Entity.
+     * @return True if this cart can be ridden.
+     */
+    public boolean canBeRidden()
+    {
+        return this.getType() == EntityMinecart.Type.RIDEABLE;
+    }
+
+    /**
+     * Getters/setters for physics variables
+     */
+
+    /**
+     * Returns the carts max speed when traveling on rails. Carts going faster
+     * than 1.1 cause issues with chunk loading. Carts cant traverse slopes or
+     * corners at greater than 0.5 - 0.6. This value is compared with the rails
+     * max speed and the carts current speed cap to determine the carts current
+     * max speed. A normal rail's max speed is 0.4.
+     *
+     * @return Carts max speed.
+     */
+    public float getMaxCartSpeedOnRail()
+    {
+        return 1.2f;
+    }
+
+    /**
+     * Returns the current speed cap for the cart when traveling on rails. This
+     * functions differs from getMaxCartSpeedOnRail() in that it controls
+     * current movement and cannot be overridden. The value however can never be
+     * higher than getMaxCartSpeedOnRail().
+     *
+     * @return
+     */
+    public final float getCurrentCartSpeedCapOnRail()
+    {
+        return currentSpeedRail;
+    }
+
+    public final void setCurrentCartSpeedCapOnRail(float value)
+    {
+        value = Math.min(value, getMaxCartSpeedOnRail());
+        currentSpeedRail = value;
+    }
+
+    public float getMaxSpeedAirLateral()
+    {
+        return maxSpeedAirLateral;
+    }
+
+    public void setMaxSpeedAirLateral(float value)
+    {
+        maxSpeedAirLateral = value;
+    }
+
+    public float getMaxSpeedAirVertical()
+    {
+        return maxSpeedAirVertical;
+    }
+
+    public void setMaxSpeedAirVertical(float value)
+    {
+        maxSpeedAirVertical = value;
+    }
+
+    public double getDragAir()
+    {
+        return dragAir;
+    }
+
+    public void setDragAir(double value)
+    {
+        dragAir = value;
+    }
+
+    public double getSlopeAdjustment()
+    {
+        return 0.0078125D;
+    }
+
+    /**
+     * Called from Detector Rails to retrieve a redstone power level for comparators.
+     */
+    public int getComparatorLevel()
+    {
+        return -1;
+    }
+
+    /* =================================== FORGE END ===========================================*/
 
     public static enum Type
     {
@@ -1075,7 +1287,7 @@
         HOPPER(5, "MinecartHopper"),
         COMMAND_BLOCK(6, "MinecartCommandBlock");
 
-        private static final Map<Integer, EntityMinecart.Type> BY_ID = Maps.newHashMap();
+        private static final Map<Integer, EntityMinecart.Type> BY_ID = Maps.<Integer, EntityMinecart.Type>newHashMap();
         private final int id;
         private final String name;
 
@@ -1098,7 +1310,7 @@
         @SideOnly(Side.CLIENT)
         public static EntityMinecart.Type getById(int idIn)
         {
-            EntityMinecart.Type entityminecart$type = BY_ID.get(idIn);
+            EntityMinecart.Type entityminecart$type = BY_ID.get(Integer.valueOf(idIn));
             return entityminecart$type == null ? RIDEABLE : entityminecart$type;
         }
 
@@ -1106,7 +1318,7 @@
         {
             for (EntityMinecart.Type entityminecart$type : values())
             {
-                BY_ID.put(entityminecart$type.getId(), entityminecart$type);
+                BY_ID.put(Integer.valueOf(entityminecart$type.getId()), entityminecart$type);
             }
         }
     }
