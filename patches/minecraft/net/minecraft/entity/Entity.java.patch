--- before/net/minecraft/entity/Entity.java
+++ after/net/minecraft/entity/Entity.java
@@ -85,7 +85,7 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-public abstract class Entity implements ICommandSender
+public abstract class Entity implements ICommandSender, net.minecraftforge.common.capabilities.ICapabilitySerializable<NBTTagCompound>
 {
     private static final Logger LOGGER = LogManager.getLogger();
     private static final List<ItemStack> EMPTY_EQUIPMENT = Collections.emptyList();
@@ -177,6 +177,10 @@
     private boolean isPositionDirty;
     private final double[] pistonDeltas;
     private long pistonDeltasGameTime;
+    /**
+     * Setting this to true will prevent the world from calling {@link #onUpdate()} for this entity.
+     */
+    public boolean updateBlocked;
 
     public Entity(World worldIn)
     {
@@ -200,7 +204,7 @@
 
         if (worldIn != null)
         {
-            this.dimension = worldIn.provider.getDimensionType().getId();
+            this.dimension = worldIn.provider.getDimension();
         }
 
         this.dataManager = new EntityDataManager(this);
@@ -211,7 +215,15 @@
         this.dataManager.register(SILENT, false);
         this.dataManager.register(NO_GRAVITY, false);
         this.entityInit();
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityEvent.EntityConstructing(this));
+        capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this);
     }
+
+    /** Forge: Used to store custom data for each entity. */
+    private NBTTagCompound customEntityData;
+    public boolean captureDrops = false;
+    public java.util.ArrayList<EntityItem> capturedDrops = new java.util.ArrayList<EntityItem>();
+    private net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
 
     public int getEntityId()
     {
@@ -357,6 +369,7 @@
         this.posX = x;
         this.posY = y;
         this.posZ = z;
+        if (this.isAddedToWorld() && !this.world.isRemote) this.world.updateEntityWithOptionalForce(this, false); // Forge - Process chunk registration after moving.
         float f = this.width / 2.0F;
         float f1 = this.height;
         this.setEntityBoundingBox(new AxisAlignedBB(x - f, y, z - f, x + f, y + f1, z + f));
@@ -1024,6 +1037,7 @@
         this.posX = (axisalignedbb.minX + axisalignedbb.maxX) / 2.0;
         this.posY = axisalignedbb.minY;
         this.posZ = (axisalignedbb.minZ + axisalignedbb.maxZ) / 2.0;
+        if (this.isAddedToWorld() && !this.world.isRemote) this.world.updateEntityWithOptionalForce(this, false); // Forge - Process chunk registration after moving.
     }
 
     protected SoundEvent getSwimSound()
@@ -1086,7 +1100,7 @@
 
     protected void playStepSound(BlockPos pos, Block blockIn)
     {
-        SoundType soundtype = blockIn.getSoundType();
+        SoundType soundtype = blockIn.getSoundType(world.getBlockState(pos), world, pos, this);
 
         if (this.world.getBlockState(pos.up()).getBlock() == Blocks.SNOW_LAYER)
         {
@@ -1320,6 +1334,7 @@
         BlockPos blockpos = new BlockPos(i, j, k);
         IBlockState iblockstate = this.world.getBlockState(blockpos);
 
+        if(!iblockstate.getBlock().addRunningEffects(iblockstate, world, blockpos, this))
         if (iblockstate.getRenderType() != EnumBlockRenderType.INVISIBLE)
         {
             this.world
@@ -1348,12 +1363,12 @@
             BlockPos blockpos = new BlockPos(this.posX, d0, this.posZ);
             IBlockState iblockstate = this.world.getBlockState(blockpos);
 
+            Boolean result = iblockstate.getBlock().isEntityInsideMaterial(this.world, blockpos, iblockstate, this, d0, materialIn, true);
+            if (result != null) return result;
+
             if (iblockstate.getMaterial() == materialIn)
             {
-                float f = BlockLiquid.getLiquidHeightPercent(iblockstate.getBlock().getMetaFromState(iblockstate)) - 0.11111111F;
-                float f1 = blockpos.getY() + 1 - f;
-                boolean flag = d0 < f1;
-                return !flag && this instanceof EntityPlayer ? false : flag;
+                return net.minecraftforge.common.ForgeHooks.isInsideOfMaterial(materialIn, this, blockpos);
             }
             else
             {
@@ -1457,6 +1472,7 @@
             this.prevRotationYaw -= 360.0F;
         }
 
+        if (!this.world.isRemote) this.world.getChunk((int) Math.floor(this.posX) >> 4, (int) Math.floor(this.posZ) >> 4); // Forge - ensure target chunk is loaded.
         this.setPosition(this.posX, this.posY, this.posZ);
         this.setRotation(yaw, pitch);
     }
@@ -1783,6 +1799,7 @@
             {
                 compound.setBoolean("Glowing", this.glowing);
             }
+            compound.setBoolean("UpdateBlocked", updateBlocked);
 
             if (!this.tags.isEmpty())
             {
@@ -1796,6 +1813,9 @@
                 compound.setTag("Tags", nbttaglist);
             }
 
+            if (customEntityData != null) compound.setTag("ForgeData", customEntityData);
+            if (this.capabilities != null) compound.setTag("ForgeCaps", this.capabilities.serializeNBT());
+
             this.writeEntityToNBT(compound);
 
             if (this.isBeingRidden())
@@ -1902,6 +1922,10 @@
             this.setSilent(compound.getBoolean("Silent"));
             this.setNoGravity(compound.getBoolean("NoGravity"));
             this.setGlowing(compound.getBoolean("Glowing"));
+            updateBlocked = compound.getBoolean("UpdateBlocked");
+
+            if (compound.hasKey("ForgeData")) customEntityData = compound.getCompoundTag("ForgeData");
+            if (this.capabilities != null && compound.hasKey("ForgeCaps")) this.capabilities.deserializeNBT(compound.getCompoundTag("ForgeCaps"));
 
             if (compound.hasKey("Tags", 9))
             {
@@ -1994,7 +2018,10 @@
         {
             EntityItem entityitem = new EntityItem(this.world, this.posX, this.posY + offsetY, this.posZ, stack);
             entityitem.setDefaultPickupDelay();
-            this.world.spawnEntity(entityitem);
+            if (captureDrops)
+                this.capturedDrops.add(entityitem);
+            else
+                this.world.spawnEntity(entityitem);
             return entityitem;
         }
     }
@@ -2063,6 +2090,7 @@
             this.motionX = 0.0;
             this.motionY = 0.0;
             this.motionZ = 0.0;
+            if(!updateBlocked)
             this.onUpdate();
 
             if (this.isRiding())
@@ -2110,6 +2138,7 @@
             }
         }
 
+        if (!net.minecraftforge.event.ForgeEventFactory.canMountEntity(this, entityIn, true)) return false;
         if (force || this.canBeRidden(entityIn) && entityIn.canFitPassenger(this))
         {
             if (this.isRiding())
@@ -2145,6 +2174,7 @@
         if (this.ridingEntity != null)
         {
             Entity entity = this.ridingEntity;
+            if (!net.minecraftforge.event.ForgeEventFactory.canMountEntity(this, entity, false)) return;
             this.ridingEntity = null;
             entity.removePassenger(this);
         }
@@ -2612,8 +2642,16 @@
     @Nullable
     public Entity changeDimension(int dimensionIn)
     {
+        if (this.world.isRemote || this.isDead) return null;
+        return changeDimension(dimensionIn, this.getServer().getWorld(dimensionIn).getDefaultTeleporter());
+    }
+
+    @Nullable // Forge: Entities that require custom handling should override this method, not the other
+    public Entity changeDimension(int dimensionIn, net.minecraftforge.common.util.ITeleporter teleporter)
+    {
         if (!this.world.isRemote && !this.isDead)
         {
+            if (!net.minecraftforge.common.ForgeHooks.onTravelToDimension(this, dimensionIn)) return null;
             this.world.profiler.startSection("changeDimension");
             MinecraftServer minecraftserver = this.getServer();
             int i = this.dimension;
@@ -2621,7 +2659,7 @@
             WorldServer worldserver1 = minecraftserver.getWorld(dimensionIn);
             this.dimension = dimensionIn;
 
-            if (i == 1 && dimensionIn == 1)
+            if (i == 1 && dimensionIn == 1 && teleporter.isVanilla())
             {
                 worldserver1 = minecraftserver.getWorld(0);
                 this.dimension = 0;
@@ -2632,17 +2670,18 @@
             this.world.profiler.startSection("reposition");
             BlockPos blockpos;
 
-            if (dimensionIn == 1)
+            if (dimensionIn == 1 && teleporter.isVanilla())
             {
                 blockpos = worldserver1.getSpawnCoordinate();
             }
             else
             {
-                double d0 = this.posX;
-                double d1 = this.posZ;
+                double moveFactor = worldserver.provider.getMovementFactor() / worldserver1.provider.getMovementFactor();
+                double d0 = MathHelper.clamp(this.posX * moveFactor, worldserver1.getWorldBorder().minX() + 16.0, worldserver1.getWorldBorder().maxX() - 16.0);
+                double d1 = MathHelper.clamp(this.posZ * moveFactor, worldserver1.getWorldBorder().minZ() + 16.0, worldserver1.getWorldBorder().maxZ() - 16.0);
                 double d2 = 8.0;
 
-                if (dimensionIn == -1)
+                if (false && dimensionIn == -1)
                 {
                     d0 = MathHelper.clamp(
                              d0 / 8.0, worldserver1.getWorldBorder().minX() + 16.0, worldserver1.getWorldBorder().maxX() - 16.0
@@ -2651,7 +2690,7 @@
                              d1 / 8.0, worldserver1.getWorldBorder().minZ() + 16.0, worldserver1.getWorldBorder().maxZ() - 16.0
                          );
                 }
-                else if (dimensionIn == 0)
+                else if (false && dimensionIn == 0)
                 {
                     d0 = MathHelper.clamp(
                              d0 * 8.0, worldserver1.getWorldBorder().minX() + 16.0, worldserver1.getWorldBorder().maxX() - 16.0
@@ -2665,8 +2704,7 @@
                 d1 = MathHelper.clamp((int)d1, -29999872, 29999872);
                 float f = this.rotationYaw;
                 this.setLocationAndAngles(d0, this.posY, d1, 90.0F, 0.0F);
-                Teleporter teleporter = worldserver1.getDefaultTeleporter();
-                teleporter.placeInExistingPortal(this, f);
+                teleporter.placeEntity(worldserver1, this, f);
                 blockpos = new BlockPos(this);
             }
 
@@ -2678,7 +2716,7 @@
             {
                 entity.copyDataFromOld(this);
 
-                if (i == 1 && dimensionIn == 1)
+                if (i == 1 && dimensionIn == 1 && teleporter.isVanilla())
                 {
                     BlockPos blockpos1 = worldserver1.getTopSolidOrLiquidBlock(worldserver1.getSpawnPoint());
                     entity.moveToBlockPosAndAngles(blockpos1, entity.rotationYaw, entity.rotationPitch);
@@ -2715,7 +2753,7 @@
 
     public float getExplosionResistance(Explosion explosionIn, World worldIn, BlockPos pos, IBlockState blockStateIn)
     {
-        return blockStateIn.getBlock().getExplosionResistance(this);
+        return blockStateIn.getBlock().getExplosionResistance(worldIn, pos, this, explosionIn);
     }
 
     public boolean canExplosionDestroyBlock(Explosion explosionIn, World worldIn, BlockPos pos, IBlockState blockStateIn, float p_174816_5_)
@@ -3026,6 +3064,218 @@
 
         EnchantmentHelper.applyArthropodEnchantments(entityLivingBaseIn, entityIn);
     }
+
+    /* ================================== Forge Start =====================================*/
+    /**
+     * Internal use for keeping track of entities that are tracked by a world, to
+     * allow guarantees that entity position changes will force a chunk load, avoiding
+     * potential issues with entity desyncing and bad chunk data.
+     */
+    private boolean isAddedToWorld;
+
+    /**
+     * Gets whether this entity has been added to a world (for tracking). Specifically
+     * between the times when an entity is added to a world and the entity being removed
+     * from the world's tracked lists. See {@link World#onEntityAdded(Entity)} and
+     * {@link World#onEntityRemoved(Entity)}.
+     *
+     * @return True if this entity is being tracked by a world
+     */
+    public final boolean isAddedToWorld() { return this.isAddedToWorld; }
+
+    /**
+     * Called after the entity has been added to the world's
+     * ticking list. Can be overriden, but needs to call super
+     * to prevent MC-136995.
+     */
+    public void onAddedToWorld() {
+        this.isAddedToWorld = true;
+    }
+
+    /**
+     * Called after the entity has been removed to the world's
+     * ticking list. Can be overriden, but needs to call super
+     * to prevent MC-136995.
+     */
+    public void onRemovedFromWorld() {
+        this.isAddedToWorld = false;
+    }
+
+    /**
+     * Returns a NBTTagCompound that can be used to store custom data for this entity.
+     * It will be written, and read from disc, so it persists over world saves.
+     * @return A NBTTagCompound
+     */
+    public NBTTagCompound getEntityData()
+    {
+        if (customEntityData == null)
+        {
+            customEntityData = new NBTTagCompound();
+        }
+        return customEntityData;
+    }
+
+    /**
+     * Used in model rendering to determine if the entity riding this entity should be in the 'sitting' position.
+     * @return false to prevent an entity that is mounted to this entity from displaying the 'sitting' animation.
+     */
+    public boolean shouldRiderSit()
+    {
+        return true;
+    }
+
+    /**
+     * Called when a user uses the creative pick block button on this entity.
+     *
+     * @param target The full target the player is looking at
+     * @return A ItemStack to add to the player's inventory, empty ItemStack if nothing should be added.
+     */
+    public ItemStack getPickedResult(RayTraceResult target)
+    {
+        if (this instanceof net.minecraft.entity.item.EntityPainting)
+        {
+            return new ItemStack(net.minecraft.init.Items.PAINTING);
+        }
+        else if (this instanceof EntityLeashKnot)
+        {
+            return new ItemStack(net.minecraft.init.Items.LEAD);
+        }
+        else if (this instanceof net.minecraft.entity.item.EntityItemFrame)
+        {
+            ItemStack held = ((net.minecraft.entity.item.EntityItemFrame)this).getDisplayedItem();
+            if (held.isEmpty())
+            {
+                return new ItemStack(net.minecraft.init.Items.ITEM_FRAME);
+            }
+            else
+            {
+                return held.copy();
+            }
+        }
+        else if (this instanceof net.minecraft.entity.item.EntityMinecart)
+        {
+            return ((net.minecraft.entity.item.EntityMinecart)this).getCartItem();
+        }
+        else if (this instanceof net.minecraft.entity.item.EntityBoat)
+        {
+            return new ItemStack(((EntityBoat)this).getItemBoat());
+        }
+        else if (this instanceof net.minecraft.entity.item.EntityArmorStand)
+        {
+            return new ItemStack(net.minecraft.init.Items.ARMOR_STAND);
+        }
+        else if (this instanceof net.minecraft.entity.item.EntityEnderCrystal)
+        {
+            return new ItemStack(net.minecraft.init.Items.END_CRYSTAL);
+        }
+        else
+        {
+            ResourceLocation name = EntityList.getKey(this);
+            if (name != null && EntityList.ENTITY_EGGS.containsKey(name))
+            {
+                ItemStack stack = new ItemStack(net.minecraft.init.Items.SPAWN_EGG);
+                net.minecraft.item.ItemMonsterPlacer.applyEntityIdToItemStack(stack, name);
+                return stack;
+            }
+        }
+        return ItemStack.EMPTY;
+    }
+
+    public UUID getPersistentID()
+    {
+        return entityUniqueID;
+    }
+
+    /**
+     * Reset the entity ID to a new value. Not to be used from Mod code
+     */
+    @Deprecated // TODO: remove (1.13?)
+    public final void resetEntityId()
+    {
+        this.entityId = nextEntityID++;
+    }
+
+    public boolean shouldRenderInPass(int pass)
+    {
+        return pass == 0;
+    }
+
+    /**
+     * Returns true if the entity is of the @link{EnumCreatureType} provided
+     * @param type The EnumCreatureType type this entity is evaluating
+     * @param forSpawnCount If this is being invoked to check spawn count caps.
+     * @return If the creature is of the type provided
+     */
+    public boolean isCreatureType(EnumCreatureType type, boolean forSpawnCount)
+    {
+        if (forSpawnCount && (this instanceof EntityLiving) && ((EntityLiving)this).isNoDespawnRequired()) return false;
+        return type.getCreatureClass().isAssignableFrom(this.getClass());
+    }
+
+    /**
+     * If a rider of this entity can interact with this entity. Should return true on the
+     * ridden entity if so.
+     *
+     * @return if the entity can be interacted with from a rider
+     */
+    public boolean canRiderInteract()
+    {
+        return false;
+    }
+
+    /**
+     * If the rider should be dismounted from the entity when the entity goes under water
+     *
+     * @param rider The entity that is riding
+     * @return if the entity should be dismounted when under water
+     */
+    public boolean shouldDismountInWater(Entity rider)
+    {
+        return this instanceof EntityLivingBase;
+    }
+
+    @Override
+    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable net.minecraft.util.EnumFacing facing)
+    {
+        return capabilities != null && capabilities.hasCapability(capability, facing);
+    }
+
+    @Override
+    @Nullable
+    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable net.minecraft.util.EnumFacing facing)
+    {
+        return capabilities == null ? null : capabilities.getCapability(capability, facing);
+    }
+
+    public void deserializeNBT(NBTTagCompound nbt)
+    {
+        this.readFromNBT(nbt);
+    }
+
+    public NBTTagCompound serializeNBT()
+    {
+        NBTTagCompound ret = new NBTTagCompound();
+        ret.setString("id", this.getEntityString());
+        return this.writeToNBT(ret);
+    }
+
+    /**
+     * Checks if this {@link Entity} can trample a {@link Block}.
+     *
+     * @param world The world in which the block will be trampled
+     * @param block The block being tested
+     * @param pos The block pos
+     * @param fallDistance The fall distance
+     * @return {@code true} if this entity can trample, {@code false} otherwise
+     */
+    public boolean canTrample(World world, Block block, BlockPos pos, float fallDistance)
+    {
+        return world.rand.nextFloat() < fallDistance - 0.5F
+            && this instanceof EntityLivingBase
+            && (this instanceof EntityPlayer || net.minecraftforge.event.ForgeEventFactory.getMobGriefingEvent(world, this))
+            && this.width * this.width * this.height > 0.512F;
+    }
+    /* ================================== Forge End =====================================*/
 
     public void addTrackingPlayer(EntityPlayerMP player)
     {
