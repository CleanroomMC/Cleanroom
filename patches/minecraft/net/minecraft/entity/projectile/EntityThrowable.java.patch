--- before/net/minecraft/entity/projectile/EntityThrowable.java
+++ after/net/minecraft/entity/projectile/EntityThrowable.java
@@ -25,9 +25,9 @@
 
 public abstract class EntityThrowable extends Entity implements IProjectile
 {
-    private int xTile = -1;
-    private int yTile = -1;
-    private int zTile = -1;
+    private int xTile;
+    private int yTile;
+    private int zTile;
     private Block inTile;
     protected boolean inGround;
     public int throwableShake;
@@ -41,6 +41,9 @@
     public EntityThrowable(World worldIn)
     {
         super(worldIn);
+        this.xTile = -1;
+        this.yTile = -1;
+        this.zTile = -1;
         this.setSize(0.25F, 0.25F);
     }
 
@@ -52,71 +55,67 @@
 
     public EntityThrowable(World worldIn, EntityLivingBase throwerIn)
     {
-        this(worldIn, throwerIn.posX, throwerIn.posY + (double)throwerIn.getEyeHeight() - 0.1F, throwerIn.posZ);
+        this(worldIn, throwerIn.posX, throwerIn.posY + (double)throwerIn.getEyeHeight() - 0.10000000149011612D, throwerIn.posZ);
         this.thrower = throwerIn;
     }
 
-    @Override
     protected void entityInit()
     {
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public boolean isInRangeToRenderDist(double distance)
     {
-        double d0 = this.getEntityBoundingBox().getAverageEdgeLength() * 4.0;
+        double d0 = this.getEntityBoundingBox().getAverageEdgeLength() * 4.0D;
 
         if (Double.isNaN(d0))
         {
-            d0 = 4.0;
+            d0 = 4.0D;
         }
 
-        d0 *= 64.0;
+        d0 = d0 * 64.0D;
         return distance < d0 * d0;
     }
 
     public void shoot(Entity entityThrower, float rotationPitchIn, float rotationYawIn, float pitchOffset, float velocity, float inaccuracy)
     {
-        float f = -MathHelper.sin(rotationYawIn * (float)(Math.PI / 180.0)) * MathHelper.cos(rotationPitchIn * (float)(Math.PI / 180.0));
-        float f1 = -MathHelper.sin((rotationPitchIn + pitchOffset) * (float)(Math.PI / 180.0));
-        float f2 = MathHelper.cos(rotationYawIn * (float)(Math.PI / 180.0)) * MathHelper.cos(rotationPitchIn * (float)(Math.PI / 180.0));
+        float f = -MathHelper.sin(rotationYawIn * 0.017453292F) * MathHelper.cos(rotationPitchIn * 0.017453292F);
+        float f1 = -MathHelper.sin((rotationPitchIn + pitchOffset) * 0.017453292F);
+        float f2 = MathHelper.cos(rotationYawIn * 0.017453292F) * MathHelper.cos(rotationPitchIn * 0.017453292F);
         this.shoot((double)f, (double)f1, (double)f2, velocity, inaccuracy);
-        this.motionX = this.motionX + entityThrower.motionX;
-        this.motionZ = this.motionZ + entityThrower.motionZ;
+        this.motionX += entityThrower.motionX;
+        this.motionZ += entityThrower.motionZ;
 
         if (!entityThrower.onGround)
         {
-            this.motionY = this.motionY + entityThrower.motionY;
+            this.motionY += entityThrower.motionY;
         }
     }
 
-    @Override
     public void shoot(double x, double y, double z, float velocity, float inaccuracy)
     {
         float f = MathHelper.sqrt(x * x + y * y + z * z);
-        x /= (double)f;
-        y /= (double)f;
-        z /= (double)f;
-        x += this.rand.nextGaussian() * 0.0075F * (double)inaccuracy;
-        y += this.rand.nextGaussian() * 0.0075F * (double)inaccuracy;
-        z += this.rand.nextGaussian() * 0.0075F * (double)inaccuracy;
-        x *= (double)velocity;
-        y *= (double)velocity;
-        z *= (double)velocity;
+        x = x / (double)f;
+        y = y / (double)f;
+        z = z / (double)f;
+        x = x + this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
+        y = y + this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
+        z = z + this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
+        x = x * (double)velocity;
+        y = y * (double)velocity;
+        z = z * (double)velocity;
         this.motionX = x;
         this.motionY = y;
         this.motionZ = z;
         float f1 = MathHelper.sqrt(x * x + z * z);
-        this.rotationYaw = (float)(MathHelper.atan2(x, z) * 180.0F / (float)Math.PI);
-        this.rotationPitch = (float)(MathHelper.atan2(y, (double)f1) * 180.0F / (float)Math.PI);
+        this.rotationYaw = (float)(MathHelper.atan2(x, z) * (180D / Math.PI));
+        this.rotationPitch = (float)(MathHelper.atan2(y, (double)f1) * (180D / Math.PI));
         this.prevRotationYaw = this.rotationYaw;
         this.prevRotationPitch = this.rotationPitch;
         this.ticksInGround = 0;
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public void setVelocity(double x, double y, double z)
     {
         this.motionX = x;
@@ -126,14 +125,13 @@
         if (this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F)
         {
             float f = MathHelper.sqrt(x * x + z * z);
-            this.rotationYaw = (float)(MathHelper.atan2(x, z) * 180.0F / (float)Math.PI);
-            this.rotationPitch = (float)(MathHelper.atan2(y, (double)f) * 180.0F / (float)Math.PI);
+            this.rotationYaw = (float)(MathHelper.atan2(x, z) * (180D / Math.PI));
+            this.rotationPitch = (float)(MathHelper.atan2(y, (double)f) * (180D / Math.PI));
             this.prevRotationYaw = this.rotationYaw;
             this.prevRotationPitch = this.rotationPitch;
         }
     }
 
-    @Override
     public void onUpdate()
     {
         this.lastTickPosX = this.posX;
@@ -143,15 +141,14 @@
 
         if (this.throwableShake > 0)
         {
-            this.throwableShake--;
+            --this.throwableShake;
         }
 
         if (this.inGround)
         {
-            if (this.world.getBlockState(new BlockPos(this.xTile, this.yTile, this.zTile)).getBlock()
-                    == this.inTile)
+            if (this.world.getBlockState(new BlockPos(this.xTile, this.yTile, this.zTile)).getBlock() == this.inTile)
             {
-                this.ticksInGround++;
+                ++this.ticksInGround;
 
                 if (this.ticksInGround == 1200)
                 {
@@ -162,15 +159,15 @@
             }
 
             this.inGround = false;
-            this.motionX = this.motionX * (double)(this.rand.nextFloat() * 0.2F);
-            this.motionY = this.motionY * (double)(this.rand.nextFloat() * 0.2F);
-            this.motionZ = this.motionZ * (double)(this.rand.nextFloat() * 0.2F);
+            this.motionX *= (double)(this.rand.nextFloat() * 0.2F);
+            this.motionY *= (double)(this.rand.nextFloat() * 0.2F);
+            this.motionZ *= (double)(this.rand.nextFloat() * 0.2F);
             this.ticksInGround = 0;
             this.ticksInAir = 0;
         }
         else
         {
-            this.ticksInAir++;
+            ++this.ticksInAir;
         }
 
         Vec3d vec3d = new Vec3d(this.posX, this.posY, this.posZ);
@@ -185,12 +182,11 @@
         }
 
         Entity entity = null;
-        List<Entity> list = this.world
-                            .getEntitiesWithinAABBExcludingEntity(this, this.getEntityBoundingBox().expand(this.motionX, this.motionY, this.motionZ).grow(1.0));
-        double d0 = 0.0;
+        List<Entity> list = this.world.getEntitiesWithinAABBExcludingEntity(this, this.getEntityBoundingBox().expand(this.motionX, this.motionY, this.motionZ).grow(1.0D));
+        double d0 = 0.0D;
         boolean flag = false;
 
-        for (int i = 0; i < list.size(); i++)
+        for (int i = 0; i < list.size(); ++i)
         {
             Entity entity1 = list.get(i);
 
@@ -208,14 +204,14 @@
                 else
                 {
                     flag = false;
-                    AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().grow(0.3F);
+                    AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().grow(0.30000001192092896D);
                     RayTraceResult raytraceresult1 = axisalignedbb.calculateIntercept(vec3d, vec3d1);
 
                     if (raytraceresult1 != null)
                     {
                         double d1 = vec3d.squareDistanceTo(raytraceresult1.hitVec);
 
-                        if (d1 < d0 || d0 == 0.0)
+                        if (d1 < d0 || d0 == 0.0D)
                         {
                             entity = entity1;
                             d0 = d1;
@@ -244,27 +240,25 @@
 
         if (raytraceresult != null)
         {
-            if (raytraceresult.typeOfHit == RayTraceResult.Type.BLOCK
-                    && this.world.getBlockState(raytraceresult.getBlockPos()).getBlock() == Blocks.PORTAL)
+            if (raytraceresult.typeOfHit == RayTraceResult.Type.BLOCK && this.world.getBlockState(raytraceresult.getBlockPos()).getBlock() == Blocks.PORTAL)
             {
                 this.setPortal(raytraceresult.getBlockPos());
             }
-            else
+            else if (!net.minecraftforge.event.ForgeEventFactory.onProjectileImpact(this, raytraceresult))
             {
                 this.onImpact(raytraceresult);
             }
         }
 
-        this.posX = this.posX + this.motionX;
-        this.posY = this.posY + this.motionY;
-        this.posZ = this.posZ + this.motionZ;
+        this.posX += this.motionX;
+        this.posY += this.motionY;
+        this.posZ += this.motionZ;
         float f = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-        this.rotationYaw = (float)(MathHelper.atan2(this.motionX, this.motionZ) * 180.0F / (float)Math.PI);
-        this.rotationPitch = (float)(MathHelper.atan2(this.motionY, (double)f) * 180.0F / (float)Math.PI);
+        this.rotationYaw = (float)(MathHelper.atan2(this.motionX, this.motionZ) * (180D / Math.PI));
 
-        while (this.rotationPitch - this.prevRotationPitch < -180.0F)
+        for (this.rotationPitch = (float)(MathHelper.atan2(this.motionY, (double)f) * (180D / Math.PI)); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
         {
-            this.prevRotationPitch -= 360.0F;
+            ;
         }
 
         while (this.rotationPitch - this.prevRotationPitch >= 180.0F)
@@ -289,19 +283,10 @@
 
         if (this.isInWater())
         {
-            for (int j = 0; j < 4; j++)
+            for (int j = 0; j < 4; ++j)
             {
                 float f3 = 0.25F;
-                this.world
-                .spawnParticle(
-                    EnumParticleTypes.WATER_BUBBLE,
-                    this.posX - this.motionX * 0.25,
-                    this.posY - this.motionY * 0.25,
-                    this.posZ - this.motionZ * 0.25,
-                    this.motionX,
-                    this.motionY,
-                    this.motionZ
-                );
+                this.world.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX - this.motionX * 0.25D, this.posY - this.motionY * 0.25D, this.posZ - this.motionZ * 0.25D, this.motionX, this.motionY, this.motionZ);
             }
 
             f1 = 0.8F;
@@ -330,7 +315,6 @@
     {
     }
 
-    @Override
     public void writeEntityToNBT(NBTTagCompound compound)
     {
         compound.setInteger("xTile", this.xTile);
@@ -349,7 +333,6 @@
         compound.setString("ownerName", this.throwerName == null ? "" : this.throwerName);
     }
 
-    @Override
     public void readEntityFromNBT(NBTTagCompound compound)
     {
         this.xTile = compound.getInteger("xTile");
@@ -396,7 +379,7 @@
                         this.thrower = (EntityLivingBase)entity;
                     }
                 }
-                catch (Throwable throwable)
+                catch (Throwable var2)
                 {
                     this.thrower = null;
                 }
