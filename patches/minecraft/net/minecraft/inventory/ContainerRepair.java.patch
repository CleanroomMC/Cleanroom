--- before/net/minecraft/inventory/ContainerRepair.java
+++ after/net/minecraft/inventory/ContainerRepair.java
@@ -22,16 +22,8 @@
 public class ContainerRepair extends Container
 {
     private static final Logger LOGGER = LogManager.getLogger();
-    private final IInventory outputSlot = new InventoryCraftResult();
-    private final IInventory inputSlots = new InventoryBasic("Repair", true, 2)
-    {
-        @Override
-        public void markDirty()
-        {
-            super.markDirty();
-            ContainerRepair.this.onCraftMatrixChanged(this);
-        }
-    };
+    private final IInventory outputSlot;
+    private final IInventory inputSlots;
     private final World world;
     private final BlockPos pos;
     public int maximumCost;
@@ -47,27 +39,30 @@
 
     public ContainerRepair(InventoryPlayer playerInventory, final World worldIn, final BlockPos blockPosIn, EntityPlayer player)
     {
+        this.outputSlot = new InventoryCraftResult();
+        this.inputSlots = new InventoryBasic("Repair", true, 2)
+        {
+            public void markDirty()
+            {
+                super.markDirty();
+                ContainerRepair.this.onCraftMatrixChanged(this);
+            }
+        };
         this.pos = blockPosIn;
         this.world = worldIn;
         this.player = player;
         this.addSlotToContainer(new Slot(this.inputSlots, 0, 27, 47));
         this.addSlotToContainer(new Slot(this.inputSlots, 1, 76, 47));
-        this.addSlotToContainer(
-            new Slot(this.outputSlot, 2, 134, 47)
+        this.addSlotToContainer(new Slot(this.outputSlot, 2, 134, 47)
         {
-            @Override
             public boolean isItemValid(ItemStack stack)
             {
                 return false;
             }
-            @Override
             public boolean canTakeStack(EntityPlayer playerIn)
             {
-                return (playerIn.capabilities.isCreativeMode || playerIn.experienceLevel >= ContainerRepair.this.maximumCost)
-                       && ContainerRepair.this.maximumCost > 0
-                       && this.getHasStack();
+                return (playerIn.capabilities.isCreativeMode || playerIn.experienceLevel >= ContainerRepair.this.maximumCost) && ContainerRepair.this.maximumCost > 0 && this.getHasStack();
             }
-            @Override
             public ItemStack onTake(EntityPlayer thePlayer, ItemStack stack)
             {
                 if (!thePlayer.capabilities.isCreativeMode)
@@ -75,6 +70,8 @@
                     thePlayer.addExperienceLevel(-ContainerRepair.this.maximumCost);
                 }
 
+                float breakChance = net.minecraftforge.common.ForgeHooks.onAnvilRepair(thePlayer, stack, ContainerRepair.this.inputSlots.getStackInSlot(0), ContainerRepair.this.inputSlots.getStackInSlot(1));
+
                 ContainerRepair.this.inputSlots.setInventorySlotContents(0, ItemStack.EMPTY);
 
                 if (ContainerRepair.this.materialCost > 0)
@@ -99,21 +96,19 @@
                 ContainerRepair.this.maximumCost = 0;
                 IBlockState iblockstate = worldIn.getBlockState(blockPosIn);
 
-                if (!thePlayer.capabilities.isCreativeMode
-                        && !worldIn.isRemote
-                        && iblockstate.getBlock() == Blocks.ANVIL
-                        && thePlayer.getRNG().nextFloat() < 0.12F)
+                if (!thePlayer.capabilities.isCreativeMode && !worldIn.isRemote && iblockstate.getBlock() == Blocks.ANVIL && thePlayer.getRNG().nextFloat() < breakChance)
                 {
-                    int l = iblockstate.getValue(BlockAnvil.DAMAGE);
+                    int l = ((Integer)iblockstate.getValue(BlockAnvil.DAMAGE)).intValue();
+                    ++l;
 
-                    if (++l > 2)
+                    if (l > 2)
                     {
                         worldIn.setBlockToAir(blockPosIn);
                         worldIn.playEvent(1029, blockPosIn, 0);
                     }
                     else
                     {
-                        worldIn.setBlockState(blockPosIn, iblockstate.withProperty(BlockAnvil.DAMAGE, l), 2);
+                        worldIn.setBlockState(blockPosIn, iblockstate.withProperty(BlockAnvil.DAMAGE, Integer.valueOf(l)), 2);
                         worldIn.playEvent(1030, blockPosIn, 0);
                     }
                 }
@@ -124,24 +119,22 @@
 
                 return stack;
             }
-        }
-        );
+        });
 
-        for (int i = 0; i < 3; i++)
+        for (int i = 0; i < 3; ++i)
         {
-            for (int j = 0; j < 9; j++)
+            for (int j = 0; j < 9; ++j)
             {
                 this.addSlotToContainer(new Slot(playerInventory, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
             }
         }
 
-        for (int k = 0; k < 9; k++)
+        for (int k = 0; k < 9; ++k)
         {
             this.addSlotToContainer(new Slot(playerInventory, k, 8 + k * 18, 142));
         }
     }
 
-    @Override
     public void onCraftMatrixChanged(IInventory inventoryIn)
     {
         super.onCraftMatrixChanged(inventoryIn);
@@ -170,12 +163,14 @@
             ItemStack itemstack1 = itemstack.copy();
             ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);
             Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);
-            j += itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());
+            j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());
             this.materialCost = 0;
+            boolean flag = false;
 
             if (!itemstack2.isEmpty())
             {
-                boolean flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();
+                if (!net.minecraftforge.common.ForgeHooks.onAnvilChange(this, itemstack, itemstack2, outputSlot, repairedItemName, j, player)) return;
+                flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();
 
                 if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2))
                 {
@@ -190,11 +185,11 @@
 
                     int i3;
 
-                    for (i3 = 0; l2 > 0 && i3 < itemstack2.getCount(); i3++)
+                    for (i3 = 0; l2 > 0 && i3 < itemstack2.getCount(); ++i3)
                     {
                         int j3 = itemstack1.getItemDamage() - l2;
                         itemstack1.setItemDamage(j3);
-                        i++;
+                        ++i;
                         l2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
                     }
 
@@ -222,7 +217,7 @@
                             l1 = 0;
                         }
 
-                        if (l1 < itemstack1.getMetadata())
+                        if (l1 < itemstack1.getItemDamage()) // vanilla uses metadata here instead of damage.
                         {
                             itemstack1.setItemDamage(l1);
                             i += 2;
@@ -237,8 +232,8 @@
                     {
                         if (enchantment1 != null)
                         {
-                            int i2 = map.containsKey(enchantment1) ? map.get(enchantment1) : 0;
-                            int j2 = map1.get(enchantment1);
+                            int i2 = map.containsKey(enchantment1) ? ((Integer)map.get(enchantment1)).intValue() : 0;
+                            int j2 = ((Integer)map1.get(enchantment1)).intValue();
                             j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);
                             boolean flag1 = enchantment1.canApply(itemstack);
 
@@ -252,7 +247,7 @@
                                 if (enchantment != enchantment1 && !enchantment1.isCompatibleWith(enchantment))
                                 {
                                     flag1 = false;
-                                    i++;
+                                    ++i;
                                 }
                             }
 
@@ -269,7 +264,7 @@
                                     j2 = enchantment1.getMaxLevel();
                                 }
 
-                                map.put(enchantment1, j2);
+                                map.put(enchantment1, Integer.valueOf(j2));
                                 int k3 = 0;
 
                                 switch (enchantment1.getRarity())
@@ -326,6 +321,7 @@
                 i += k;
                 itemstack1.setStackDisplayName(this.repairedItemName);
             }
+            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) itemstack1 = ItemStack.EMPTY;
 
             this.maximumCost = j + i;
 
@@ -367,7 +363,6 @@
         }
     }
 
-    @Override
     public void addListener(IContainerListener listener)
     {
         super.addListener(listener);
@@ -375,7 +370,6 @@
     }
 
     @SideOnly(Side.CLIENT)
-    @Override
     public void updateProgressBar(int id, int data)
     {
         if (id == 0)
@@ -384,7 +378,6 @@
         }
     }
 
-    @Override
     public void onContainerClosed(EntityPlayer playerIn)
     {
         super.onContainerClosed(playerIn);
@@ -395,20 +388,18 @@
         }
     }
 
-    @Override
     public boolean canInteractWith(EntityPlayer playerIn)
     {
-        return this.world.getBlockState(this.pos).getBlock() != Blocks.ANVIL
-               ? false
-               : playerIn.getDistanceSq(
-                   (double)this.pos.getX() + 0.5,
-                   (double)this.pos.getY() + 0.5,
-                   (double)this.pos.getZ() + 0.5
-               )
-               <= 64.0;
+        if (this.world.getBlockState(this.pos).getBlock() != Blocks.ANVIL)
+        {
+            return false;
+        }
+        else
+        {
+            return playerIn.getDistanceSq((double)this.pos.getX() + 0.5D, (double)this.pos.getY() + 0.5D, (double)this.pos.getZ() + 0.5D) <= 64.0D;
+        }
     }
 
-    @Override
     public ItemStack transferStackInSlot(EntityPlayer playerIn, int index)
     {
         ItemStack itemstack = ItemStack.EMPTY;
